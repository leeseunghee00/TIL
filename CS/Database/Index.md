### 🔎 인덱스란 ?
> 인덱스는 데이터베이스에서 **데이터를 빠르게 검색하고 접근하기 위해** 사용되는 자료 구조이다.

- 레코드 검색 시 전체 검색이 아닌 인덱스로 검색하여 빠른 검색이 가능해 진다.
<br>

### 🔎 언제 인덱스를 만드는 게 좋을까 ?
- `WHWER`, `JOIN` 문에서 자주 사용되는 컬럼
- 데이터의 중복도가 적은 컬럼
- 외래키가 사용되는 열
<br>

### 🔎 인덱스를 사용하는 이유는 ?
> _일반적으로 데이터베이스는 테이블에 대한 쿼리 작업을 수행할 때 전체 데이터를 순차적으로 검색하는 선형 검색 방식을 사용한다. 하지만 데이터베이스가 크고 복잡해지면 이러한 선형 검색은 많은 리소스를 요구하게 된다. <br>
→ 이러한 문제를 해결하기 위해 인덱스를 사용한다._

<br>

### 🔎 인덱스의 장단점
#### ✅ 장점
- 테이블의 검색 및 정렬 속도를 향상한다.
- 고유성 제약 조건을 적용하고 데이터의 일관성과 무결성을 유지한다.
<br>

#### ✅ 단점
- 여러 사용자가 한 페이지에 동시에 수정할 수 있는 병행성이 줄어든다.
- DML에 취약하기 때문에, 데이터를 `INSERT` / `DELETE` / `UPDATE` 시 성능이 감소한다. 
<br>

### 🔎 인덱스를 생성하는 데 B-Tree를 사용하는 이유
> 각 노드가 여러 개의 key를 갖고, 자식 노드들 사이에 키 값 범위를 나누어 저장하는 구조를 가지고 있어, **트리의 높이를 최소화**하면서 빠른 검색과 삽입/삭제 연산에 효율적이다.

- _" O(1) 로 접근할 수 있는 Hash Table 이 더 효율적이다 "_ 라고 생각할 수 있지만, **등호 연산이 아닌 부등호 연산의 경우에 문제가 발생한다.** 
→ 동등 연산에 특화된 Hash Table 은 데이터베이스의 자료구조로 적합하지 않다.

<br>

### 🔎 클러스터형 인덱스 vs 넌클러스터형 인덱스 에 대해 설명해줘
> _클러스터형 인덱스는 테이블의 **정렬된** 형태로 저장하는 방식이다._

- 테이블당 하나의 클러스터형 인덱스만 가질 수 있다.
- 주로 테이블의 기본키(PK) 에 대해 생성된다.
- 데이터베이스 내에서 물리적인 데이터 순서와 인덱스 순서가 일치하므로, 데이터를 검색할 때 빠른 응답 시간을 제공한다.
- 클러스터형 인덱스의 생성은 데이터의 물리적인 재정렬이 필요하기 때문에, `INSERT` / `DELETE` / `UPDATE` 시 오버헤드가 발생할 수 있다.

> _넌클러스터형 인덱스는 별도의 인덱스 구조를 생성하여 **테이블과 별개로** 관리하는 방식이다._

- 테이블당 여러 개의 넌클러스터형 인덱스를 가질 수 있다.
- 주로 테이블의 비기본키(NON-PK) 열에 대해 생성된다.
- 데이터의 논리적인 순서를 유지하지 않지만, 데이터의 `INSERT` / `DELETE` / `UPDATE` 시 시 오버헤드가 적다. 
