### 🔎 JPA란 ?
> JPA는 **자바 ORM 기술에 대한 API 표준 명세**를 말한다.

- JPA 를 사용해 객체 지향적인 코드를 유지하면서 DB와의 상호작용을 간단하게 처리할 수 있다.

### 🔎 ORM이란 ?
> ORM은 Object Relational Mapping의 약자로, **객체 관계 DB의 데이터를 자동으로 매핑해주는 것**을 말한다.

- 여기서 객체 지향 프로그래밍은 클래스를 사용하고, 관계형 DB는 테이블을 사용한다.

### 🔎 JPA를 쓰는 이유는 ?
> 1. 개발자는 DB와의 상호작용을 위한 SQL 코드를 작성할 필요가 없다. 
- 대신 JPA 가 객체를 DB에 매핑하고 처리한다.

> 2. DB 종류에 상관없이 사용할 수 있다.
- 다양한 DB에 대한 지원을 제공하기 때문에 → 다른 DB로 이전할 때도 코드를 수정할 필요가 없다.

> 3. DB와의 연결을 관리하기 때문에, 애플리케이션에서의 DB 연결 오버헤드를 줄여준다.

_✅ 이러한 이유들로 인해, JPA는 JAVA에서 DB와의 상호작용을 처리할 때 많이 사용되는 기술 중 하나이다._

### 🔎 영속성 컨텍스트란 ?
> 영속성 컨텍스트는 **엔티티를 영구 저장하는 환경**을 말한다.

엔티티 매니저를 생성하면 자동으로 영속성 컨텍스트가 생성되고 엔티티를 관리/보관할 수 있다.

### 🔎 영속성 컨텍스트의 속성 설명해봐라
> 영속성 컨텍스트의 속성은 **비영속 / 영속 / 준영속 / 삭제 **가 있다.

- 비영속 : 영속성 컨텍스트와 전혀 무관한 상태로, **순수한 객체의 상태**를 말한다.
- 영속 : 영속성 컨텍스트에 **저장된 상태**를 말한다.
- 준영속 : 영속성 컨텍스트에서 **분리된 상태**를 말한다.
\- 영속 상태였던 적이 있었기 때문에 → `@Id` 값을 가지고 있다.
- 삭제 : **삭제된 상태**를 말한다.

### 🔎 영속성 컨텍스트의 특징 설명해봐
> 1. **1차 캐시**를 가지고 있다.
- 내부적으로 1차 캐시를 가지고 있어서 같은 객체를 반복해서 조회할 때 캐시에서 바로 객체를 가져올 수 있다.

> 2. 라이프사이클을 가지고 있다.
- 객체가 영속성 컨텍스트에 `추가`되면 → `영속` 상태로 변하고, 관리된다.
- 이후 `수정`되면 → `준영속` 상태가 되고
- `삭제`되면 → `삭제` 상태가 된다.

> 3. **지연 로딩 제공**
- 연관된 객체를 조회할 때, 필요한 시점에서 DB에서 가져와서 객체 그래프를 구성할 수 있다.

> 4. 변경 감지
- 트랜잭션 범위에서 동작하기 때문에 **트랜잭션이 커밋되거나 롤백되면** 
→ 영속성 컨텍스트에서 관리하는 모든 **객체의 상태가 적용되거나 취소된다.**


### 🔎 영속성 컨텍스트의 이점을 설명해봐
> 1. 객체 상태 관리를 자동으로 처리해 준다.

☞ 즉, DB에 변경사항을 반영하기 위해 별도로 코드를 작성하지 않아도 된다.

> 2. 중복된 데이터를 제거해주는 캐시 기능을 제공한다.

☞ 이를 통해 동일한 객체를 여러 번 조회하는 경우, DB에 접근하지 않고 영속성 컨텍스트에서 객체를 가져올 수 있다.

> 3. 트랜잭션을 지원하기 때문에 한 번에 여러 개의 객체를 처리할 수 있다.

_✅ 이러한 영속성 컨텍스트의 이점들은 **애플리케이션의 성능을 향싱**시키고, 개발자의 **생산성을 높여준다.**_

### 🔎 즉시 로딩과 지연 로딩의 차이점 말해봐라
> 즉시로딩(`Eager`)은 엔티티즐 조회할 때, **연관된 엔티티도 함께 조회**한다.
- 이 로딩은 DB와의 상호 작용을 줄이고, 성능을 최적화할 수 있다.

> 지연로딩(`Lazy`)은 **연관된 엔티티를 실제 사용할 때 조회**한다.
- 이 로딩은 메모리 사용량을 줄이고, 성능을 향상시킬 수 있다.

🌷 예를 들어, Question과 그에 해당하는 List를 함께 조회할 때, 
- Eager를 사용하면 → 한 번의 쿼리로 Question과 List 모두를 가져올 수 있다.
- Lazy를 사용하면 → Question을 먼저 조회하고, 그 후에 해당하는 List 데이터만 가져올 수 있다.



### 🔎 더티 체킹(Dirty Checking)이란 ? 
> _더티 체킹은 **트랜잭션 안에서 엔티티의 변경이 일어났을 때, 변경한 내용을 자동으로 DB에 반영하는 것**을 말한다._
- Dirty = 상태의 변화가 생겼다.
- Checking = 검사해보자 !

더티 체킹을 검사하는 대상은 **영속성 컨텍스트가 관리하는 엔티티**이다.

#### ✅ 더티 체킹은 다음과 같은 방식으로 진행된다.
1. 엔티티 조회
2. 조회된 엔티티 수정
3. 트랜잭션이 커밋되기 전에 JPA는 영속성 컨텍스트를 검사하여 변경된 엔티티를 감지
4. 변경된 엔티티의 상태를 **`수정됐음(dirty)` **으로 표시
5. 트랜잭션이 커밋되면 
→ JPA는 영속성 컨텍스트에 저장된 모든 변경된 엔티티를 DB에 반영

#### ✅ 더티 체킹의 이점
- 개발자는 변경된 엔티티를 별도로 추적하거나 DB 코드를 작성할 필요가 없다.
⇒ 객체 지향적인 방식으로 데이터를 다룰 수 있다 !
⇒ _**코드의 가독성 & 유지보수성을 높일 수 있다 !**_

### 🔎 N+1 문제가 발생하는 이유
> N+1 문제란 JPA를 사용할 때 일부 연관 관계를 `Eager` (즉시 로딩)으로 설정하고, 이와 연관된 데이터를 가져올 때, SQL 쿼리가 N번 발생하여 성능 문제가 발생하는 현상을 말한다.
