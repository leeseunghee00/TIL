## 13.1 파일 개념

> *운영체제는 컴퓨터 시스템을 편리하게 사용하기 위해 저장된 정보에 대한 일관된 논리적 관점을 제공하고 저장장치의 물리적 특성을 추상화하여 논리적 저장단위 즉, **파일**을 정의한다.*
> 
- 파일은 운영체제에 의해서 물리 장치들로 사상되며 이들 저장장치들은 일반적으로 **비휘발성**이기 때문에 시스템이 재부팅되어도 **저장된 내용은 영구히 존속**된다.

- 파일은 보조저장치에 기록된 관련 정보의 집합을 정의할 수 있다.
    - 사용자 입장 → 파일은 논리적 보조저장장치의 가장 작은 할당 요소이다.
        - 즉, 자료가 파일 안에 존재해야만 보조저장장치에 기록될 수 있다.

- 파일은 프로그램(소스 프로그램과 목적 프로그램)과 자료를 나타낸다.

- 파일 내의 정보는 **작성자에 의해 정의**된다.
    - **텍스트 파일**은 행들로 (그리고 페이지들로) 구성되는 연속된 문자들이다.
    - **소스 파일**은 함수들의 연속으로, 각 함수는 선언과 실행문의 순서로 구성된다.
    - **실행파일**은 로더가 메모리로 가져와 실행시킬 수 있는 연속된 코드 부분들이다.

### 13.1.1 파일 속성

> 사용자의 편의를 위해 파일에 이름을 부여하고, 그 이름으로 파일을 참조한다.
> 
- 파일 이름은 하나의 문자열로 나타난다.
    - 일부 시스템들은 동일 문자로 취급한다.

> 파일은 운영체제마다 다른 속성을 갖지만 전형적으로 다음과 같은 속성들을 가진다.
> 
- **이름** = 사람이 읽을 수 있는 형태로 유지된 유일한 정보이다.
- **식별자(identifier)** = 통상 하나의 숫자로 파일 시스템 내에서 파일을 확인한다. (우리가 읽을 수 없는 파일의 이름이다.)
- **유형** = 여러 유형을 제공하는 시스템을 위해 필요하다.
- **위치** = 파일이 존재하는 장치와 그 장치 내의 위치에 대한 포인터이다.
- **크기** = 파일의 현재 크기(바이트, 워드 or 블록들)와 최대 허용 가능한 크기가 이 속성에 포함된다.
- **보호** = 접근 제어 정보는 누가 읽기, 쓰기, 실행 등을 할 수 있는가를 제어한다.
- **타임스탬프와 사용자 식별** = 생성, 최근 변경, 최근 사용 등을 유지하고, 이들 자료는 보호, 보안 및 사용자 감시를 위해 사용된다.

- 몇몇 새로운 파일 시스템은 파일의 문자 인코딩 정보와 파일 체크섬과 같은 보안 정보들을 포함하여 **확장된 파일 속성(extended fild attributes)** 도 지원한다.
    - 아래 그림은 macOS의 **파일 정보 창**을 보인다.
    
    ![image](https://user-images.githubusercontent.com/87460638/236997456-f94ed61f-3a67-4157-b833-ec3ed6a78a1f.png)
    

> 모든 파일에 대한 정보는 파일 자신과 같은 장치에 상주하는 디렉터리 구조에 의해서 유지된다.
> 
- 전형적으로 디렉터리 항목은 파일의 이름과 고유의 식별자로 구성된다.
    - 식별자는 다시 다른 파일 속성을 찾는데 사용된다.
    - 디렉터리는 파일의 휘발성과 일치해야 하므로
        - → 파일과 같은 장치에 저장되어야 하고,
        - → 필요할 때마다 메모리고 조금씩 반입된다.

### 13.1.2 파일 연산

- 파일은 추상적인 데이터 유형이다.
    
    ⇒ 따라서 파일을 적절히 정의하기 위해 파일에 대해 실행할 수 있는 연산을 고려해 봐야 한다 !
    

> *운영체제는 다음과 같은 7가지 시스템 콜을 제공한다.*
> 
> 
> *→ 이들에 대해서 운영체제가 해야 할 일이 무엇인지 알아보자.*
> 
- **파일 생성**
    - 2단계로 구성된다.
    
    1) 파일을 저장할 수 있도록 파일 시스템 내에서 공간을 찾아야 한다.
    
    2) 새로 생성된 파일에 대한 항목이 디렉터리에 만들어져야 한다.
    
- **파일 열기**
    - 모든 파일 연산에서 파일 이름을 지정하게 하면 파일 생성과 삭제를 제외한 모든 연산을 하기 전에 **반드시 `open()` 해야 한다.**
    - 성공하면 → 다른 콜의 인자로 사용되는 파일 핸들을 반환한다.

- **파일 쓰기**
    - 열린 파일 핸들과 파일에 기록될 정보를 명시하는 시스템 콜을 실행한다.
    - 시스템은 파일 내의 다음 순차적 쓰기가 일어날 위치를 가리키는 **쓰기 포인터(write pointer)**를 유지해야 한다.
    - 쓰기 포인터는 **쓰기가 일어날 때마다 갱신**되어야 한다.

- **파일 읽기**
    - 파일 핸들과 파일이 읽혀야 할 블록의 위치를 기술하는 시스템 콜을 사용한다.
    - 시스템은 다음 순차적 읽기가 일어날 파일 안의 위치를 가리키는 읽기 포인터(read pointer)를 유지해야 한다.
    - 읽기 포인터 역시 **읽기가 일어날 때마다 갱신**되어야 한다.
    - 대부분의 시스템은 하나의 **현재 파일 위치 포인터**를 가진다.
        - ⇒ 읽기와 쓰기 연산 모두 이 포인터를 사용함으로써 *공간을 절약하고 시스템의 복잡성을 감소시킨다.*

- **파일 안에서의 위치 재설정(reposition)**
    - 열린 파일의 현재 파일 위치를 주어진 값으로 설정한다.
    - 파일 내에서 위치의 재설정을 위해 실제로 입출력할 필요는 없다.
    - 이 파일 연산은 **파일 탐색(seek)**으로도 알려져 있다.

- **파일 삭제**
    - 지정된 파일을 디렉터리에서 찾고, 모든 파일 공간을 해제하고 디렉터리 항목을 지우거나 사용 가능으로 표시한다.
        - 일부 시스템은 동일한 파일에 대해 여러 개의 이름(디렉터리 항목)이 존재할 수 있는 **하드 링크**를 허용한다.

- **파일 절단**
    - 사용자가 파일의 내용은 지우지만 파일의 속성은 그대로 남기기를 원할 때 사용한다.
    - 파일의 길이가 0으로 재설정되며 파일이 가지고 있던 공간은 해제될 수 있다.

> 대부분의 파일 연산들은 지명된 파일과 관련된 디렉터리를 찾는 작업을 한다. 
→ `open()` 시스템 콜 실행
> 
- 운영체제는 모든 열린 파일에 대한 정보를 갖는 **열린 파일 테이블(open-file table)**을 유지한다.
    - 파일이 사용되지 않으면 프로세스에 의해 닫히고 운영체제는 열린 파일 테이블에 있는 항목을 제거하며, 락을 해제할 수 있다.

- 일반적으로 열린 파일 테이블은 파일을 연 프로세스 수를 가리키는 **열린 계수(open count)**를 각 파일에 연관해 두고 있다.
    - 파일 `close()` 는 이 계수를 감소시키고,
    - 계수가 0이 되었을 때 → 파일은 더는 사용되지 않음을 나타내고 열린 파일 테이블로부터 제거한다.

> 몇몇 운영체제는 열린 파일(or 파일의 섹션)을 락킹(locking)할 수 있는 기능을 제공한다.
> 
- **파일 락** 은 하나의 프로세스가 파일을 잠그고 다른 프로세스들이 그것에 대한 접근하는 것을 막는데 사용될 수 있다.
    - 여러 프로세스에 의해 많은 프로세스들에 의해서 사용되고 수정되는 시스템 로그 파일과 같은 공유되는 파일들에 유용하다.
    - Java의 파일 락킹 예제
        
        ![image](https://user-images.githubusercontent.com/87460638/236997845-406ed66f-0c56-489a-b860-4804146b1f12.png)
        
    
- **공유 락(shared lock)** 은 여러 프로세스가 동시에 락을 획득할 수 있다.
    - 읽기 락과 비슷하다.

- **배타적인 락(exclusive lock)** 은 한번에 한 프로세스만 락을 획득할 수 있다.
    - 쓰기 락과 비슷하다.

> *운영체제는 **강제적** 또는 **권고적** 파일 락 방법을 제공할 수 있다.*
> 
- 강제적 락의 경우
    - 어떠한 프로세스가 배타적 락을 획득하면 운영체제는 **다른 프로세스가 잠겨진 파일에 접근하는 것을 막을 것**이다.

- 권고적 락의 경우
    - 강제적 락과 다르게 운영체제는 **다른 프로세스가 잠겨진 파일에 접근하는 것을 막지 않을 것**이다.

<aside>
💡 *파일 락 체계가 강제적이라면, 운영체제는 락 무결성을 안전하게 보장해준다.
권고적 락일 경우는, 락이 적절히 획득되고 해제되는 것에 대한 보장은 소프트웨어 개발자의 몫이다.*

</aside>

… Windows OS는 강제적 락, UNIX OS는 권고적 락을 채택하고 있다.

- 파일 락을 사용할 때 특별한 주의가 필요하다.
    - 예를 들어, 강제적 락을 사용하는 시스템에서 개발하고 있는 프로그래머는 
    → 파일에 접근할 때만 배타적 락을 가지도록 해야만 한다.
    - 그렇지 않다면 → 다른 프로세스가 그 파일에 접근하는 것이 허용되지 않는다.
    - 또한 두 개 이상의 프로세스가 파일 락을 얻음으로서 생길 수 있는 교착 상태 상황이 되지 않도록 특별하 대책이 반드시 취해져야만 한다.

### 13.1.3 파일 유형

> *전체 운영체제 설계 시 중요한 사항 중 하나는 **운영체제가 파일 유형들을 인식하고 지원할 것인지를 결정하는 것이다.***
> 
- 운영체제가 파일 유형을 지원한다면 → 파일에 대해 합리적인 연산을 수행할 수 있다.

- 흔히 잘 알려진 방법은 파일 이름의 한 부분이 파일 유형을 나타내도록 하는 것이다.
    - 파일 이름이 마침표로 구분되는 이름과 확장자 두 부분으로 나뉘게 된다.
    - 대부분 운영체제에서 사용자는 마침표와 추가적인 확장자의 파일 이름을 사용할 수 있다.
        
        ex) `server.c`, `resume.docx`  
        

![image](https://user-images.githubusercontent.com/87460638/236997800-978d0bd2-4eaa-4464-9fc1-5dc09db9837f.png)

> *시스템은 파일 유형에 따라 파일 연산 명령을 결정한다.*
> 
- `.sh` 파일은 운영체제에 전달되는 명령을 ASCII 형식으로 저장하고 있는 **셀 스크립트**이다.

- 응용 프로그램들 자신들에게 필요한 파일 유형을 나타내기 위하여 확장자를 사용한다.
    - 사용자가 확장자 없이 파일을 지정하면 응용 프로그램이 주어진 이름과 자신이 기대하는 확장자를 가진 파일을 찾는다.
    - 이들 확장자는 운영체제가 지원하는 것은 아니기 때문에, 이들은 응용 프로그램이 동작하는 파일들에 대한 힌트로 생각될 수 있다.

- macOS 운영체제에서는 각 파일은 `.app` 와 같은 파일 유형을 가지며, 또 각 파일은 자신을 생성한 프로그램의 이름을 파일의 속성으로 가진다.
    - 이 속성은 `create()` 호출 중에 운영체제에 의해 설정되고,
    - 사용시 시스템에 의해서 감시되고 유지된다.

- UNIX 시스템은 일부 이진 파일의 시작 부분에 저장된 **매직 넘버**를 사용하여 파일의 데이터 유형을 나타낸다.
    - 텍스트 파일의 시작 부분에 텍스트 매직 번호를 사용하여 파일 유형 등을 나타낸다.

### 13.1.4 파일 구조

> 파일의 유형을 사용하여 파일의 내부 구조 형태를 짐작할 수 있다.
> 
- 각각의 파일들은 그 파일을 다루는 프로그램에 의해 인식 가능한 구조를 일정한 형태로 가지게 된다.
    - 어떤 파일들의 경우에는 운영체제가 인식할 수 있도록 미리 정해진 구조를 따라야 할 때도 있다.
    - 이러한 경우를 확장하여 어떤 운영체제는 그 시스템이 지원 가능한 파일 구조를 정의하고 그러한 구조를 가지는 파일을 다룰 수 있는 특별한 연산 기능을 제공한다.

- 운영체제가 여러 파일 구조를 지원하는 경우에 발생 가능한 단점의 하나는 운영체제의 크기가 커지고 관리하기 힘들어진다는 점이다.
    - 만일 운영체제가 5가지의 다른 파일 구조를 지원한다면 
    → 이러한 파일 구조를 지원하기 위한 코드가 부가적으로 필요하다.
    - 또한 운영체제에서 지원하는 파일 유형 중 하나로만 정의되어야 하는 것이 필요할 수 있다.
    - 운영체제에서 지원하지 않는 파일 유형이 요구되는 새로운 응용 프로그램의 경우에는 더욱 심각한 문제가 발생할 수도 있을 것이다.

- 어떤 운영체제들은 파일 형태, 구조에 대하여 제한을 거의 두지 않는다.
    - 대표적인 예로 UNIX와 Windows가 있다.

### 13.1.5 파일의 내부 구조

- 디스크 시스템은 보통 섹터의 크기에 의해 결정되는 블록 크기를 가진다.
    - 모든 디스크 I/O는 한 블록 단위로 수행되며 모든 디스크 블록들은 동일한 크기를 가진다.
    - 논리 레코드의 길이는 매우 다양하며 여러 논리 레코드를 하나의 물리 레코드에 팩킹(packing)하는 것이 일반적이다.

- 논리 레코드의 크기, 물리 블록 크기, 팩킹 기술은 각 물리 블록 내에 몇 개의 논리 블록이 들어갈지 결정한다
    - 팩킹은 사용자의 응용 프로그램이나 운영체제에 의해 수행될 수 있다.

- 디스크 공간은 항상 블록 단위로 할당되기 때문에 각 파일의 마지막 블록의 일부는 낭비된다.
    - 이렇게 낭비되는 것을 **내부 단편화(internal fragmentation)**라 한다.
    - ex) 한 블록이 512바이트이고 파일의 크기가 1949바이트일 경우 
    → 4 블록(2048 바이트)이 할당되고 마지막 99바이트는 낭비될 것이다.

- 모든 파일 시스템은 내부 단편화의 문제를 갖고 있다.
    - ***블록 크기가 클수록 내부 단편화가 커진다.***

## 13.2 접근 방법

> *파일이 사용될 때는 반드시 파일 정보에 접근되어 컴퓨터 메모리로 읽혀야 한다.*
> 
- 시스템에 따라 파일에 대해 단 하나의 접근 방법을 제공하거나 여러 접근 방법을 지원하기도 한다.

### 13.2.1 순차 접근

> 가장 간단한 접근 방법은 **순차 접근** 이다.
> 
- 저장되어 있는 ***레코드 순서로 접근***한다.
    - 마치 오디오의 카세트테이프를 재생하는 방식처럼 접근한다.

- 파일에 대한 대부분의 연산은 읽기(read)와 쓰기(write)이다.
    - 읽기는 파일의 다음 부분부터 차례로 읽어 나간다.
    - 쓰기는 파일의 끝에 추가하여 새로운 파일의 끝으로 파일 포인터가 이동한다.

- 순차접근은 테이프 모델에 기반하여 임의 접근 장치는 물론 순차 접근 장치에서도 사용할 수 있따.
    
    ![image](https://user-images.githubusercontent.com/87460638/236997722-f75025ae-b17a-4858-b932-fe87eeaf7f7f.png)
    

### 13.2.2 직접 접근

> **직접접근**은 **상대 접근**이라고도 불린다.
> 
- 직접 접근을 위해서 파일은 고정 길이의 논리 레코드의 집합으로 정의되고
    - 직접 접근 파일은 어떠한 블록이라도 직접 액세스할 수 있다.

- 직접 접근 방법은 파일의 디스크 모델에 기반한다.
    - 이는 디스크가 임의의 파일 블록에 임의적 접근을 허용하기 때문이다.

- 직접 접근을 위해 파일은 번호를 갖는 일련의 블록 또는 레코드로 간주한다.
    - 직접 접근 파일은 임의의 블록을 읽거나 쓸 수 있게 한다.
    - 읽기나 쓰기의 순서는 제약이 없다.

> ***직접 접근 파일은 대규모의 정보를 다루는데 아주 유용하다.***
> 

> 직접 접근 방법을 위해서는 파일 연산이 블록 번호 파라미터를 포함할 수 있도록 수정되어야 한다.
> 
- n이 블록 번호라고 할 때, `read_next()` 대신에 `read(n)` 으로 `write_next()` 대신에 `write(n)` 을 사용할 수 있다.
    - 대체 방안으로 `read_next()` 대신에 `write_next()` 를 유지하면서 `position_file(n)` 을 추가할 수 있다.

> 사용자가 사용하는 블록 번호 n은 통상 파일의 시작을 0으로 보고 계산한 레코드의 위치로써 **상대 블록 번호(relative block number)**라고 한다.
> 
- 상대적 블록 번호를 사용하기 위해서는 운영체제가 파일이 어디에 저장되어야 하는지를 결정해야만 하고, 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 막을 수 있게 한다.

- 그렇다면 시스템은 파일의 N번째 레코드에 대한 요청을 처리할 수 있을까 ?
    - 논리적 레코드 길이가 L이라고 가정하면, N 번째 레코드에 대한 요청은 파일의 L * (N)의 위치로부터 L byte에 대한 요청이 된다.
    - 논리적 레코드는 고정된 길이이므로, 레코드를 읽고, 쓰고, 지우는 것은 간단하다.

> 모든 운영체제가 직접 접근 파일과 순차 접근 파일을 둘 다 제공하지는 않는다.
> 
- 그러나 직접 접근 파일이 있으면 순차 파일 기능을 쉽게 제공해 줄 수는 있다.
    - 반면, 순차 접근 파일에서 직접 접근을 흉내내는 것은 비효율적이며 깔끔하지도 않다.

![image](https://user-images.githubusercontent.com/87460638/236998053-f1fe1992-4fd0-43b5-98bd-5420d7273533.png)

### 13.2.3 기타 접근 방법

- 직접 접근 파일이 있으면 그것을 기반으로 여러 가지 다른 파일 접근 방법을 제공할 수 있다.
    - 대부분 파일에 대한 **색인(index)**을 사용한다.

- 색인은 여러 부분에 대한 **포인터를 제공**하는 것이다.
    - 찾고자 하는 레코드가 있으면 먼저 이 색인부터 찾아 그에 대응하는 포인터를 얻는다.
    - 그런 다음 그 포인터를 사용하여 파일을 직접 접근하고 원하는 레코드를 찾는다.

- 파일이 아주 크면 색인 자체도 매우 커 메모리에 다 들어가지 못할 수 있으므로 그것 자체를 파일로 만들어 주어야 한다.
    - **일차 색인 파일**은 2차 색인 파일의 포인터를 가지고, 이는 다시 실제 자료 항목을 가리킨다.
    
    ![image](https://user-images.githubusercontent.com/87460638/236998081-f2ad5aa6-3dfa-4e24-9580-59ce076d0569.png)
    

## 13.3 디렉터리 구조

- 디렉터리는 파일 이름을 상응하는 파일 제어 블록으로 바꾸어 주는 심볼 테이블로 볼 수 있다.
    - 만약, 이러한 관점을 가진다면, 디렉터리 그 자체가 여러 가지 방법으로 구성될 수 있다는 것을 알게 될 것이다.

> 특정한 디렉터리 구조를 고려할 때, 각 디렉터리에 수행될 수 있는 연산을 주의 깊게 살펴봐야 한다.
> 
> - 다음은 디렉터리에 대한 연산을 보여준다.
- **파일 찾기**
    - 파일 이름은 심볼릭한 형태를 가지며 비슷한 이름은 파일 간의 관계를 암시할 수 있으므로, 특정 패턴과 일치하는 이름을 갖는 모든 파일을 찾을 수 있어야 한다.

- **파일 생성**
    - 새로운 파일을 생성하여 디렉터리에 첨가한다.

- **파일 삭제**
    - 더는 필요하지 않은 파일을 디렉터리에서 삭제한다.

- **디렉터리 나열**
    - 디렉터리에 존재하는 파일을 나열하고, 파일에 대한 디렉터리 항목의 내용을 보여준다.

- **파일의 재명명**
    - 파일의 이름을 변경할 수 있어야 한다.
    - 만약 변경된 이름이 기존의 이름보다 커져 기존의 디렉터리 항목에 반영될 수 없는 경우
    → 디렉터리 구조 내에서 항목의 위치가 변경되어야 하는 예도 있을 수 있다.

- **파일 시스템의 순회(traverse)**
    - 파일 시스템의 여러 디렉터리를 순회해 다니며 파일을 볼 수 있게 해주는 기능은 매우 유용하다.
    - 또 신뢰성 측면을 고려하면 파일 시스템 구조와 관련된 정보를 주기적으로 자기 테이프, 다른 보조저장장치 또는 네트워크를 통해 다른 시스템에 또는 클라우드에 저장해 두는 것이 좋다.
        - 이 기법은 시스템 장애 시 백업 사본을 제공한다.
    - 파일이 더는 사용되지 않는 경우
    → 파일은 백업 장치에 복사되고, 디스크 공간이 해제되어 다른 파일에 의해 재사용될 수 있다.

### 13.3.1 1단계 디렉터리

> 가장 간단한 디렉터리 구조가 1단계 디렉터리(single-level directory)이다.
→ 모든 파일이 다 같이 한 개의 디렉터리 밑에 있으므로 개념이 간단하다.
> 

![image](https://user-images.githubusercontent.com/87460638/236998108-a3c15f9b-1642-41fa-a4a6-b51117e1ca05.png)

- 이 구조는 파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 심각한 제약을 가지고 있다.
    - 같은 디렉터리에 있는 모든 파일이 존재함으로 각 파일들은 유일한 이름을 가져야 한다.

- 한 명의 사용자가 사용한다 할지라도, 파일의 이름이 증가함에 따라서 모든 파일의 이름을 기억하는 것은 어려울 수 있다.

### 13.3.2 2단계 디렉터리

> 1단계의 해결책으로 각 사용자에게 서로 다른 디렉터리를 만들어 주는 것이다.
> 

![image](https://user-images.githubusercontent.com/87460638/236998133-fbdb3e66-e38d-493f-83fd-0502e03f8f55.png)

- **2단계 디렉터리(two-level directory)** 구조는 각 사용자는 자신만의 UFD 디렉터리(user file directory)를 가지고, UFD는 비슷한 구조로 되어 있지만, **각 디렉터리에는 오직 한 사람의 파일만 저장한다.**

- 사용자 작업이 시작되거나, 시스템에 사용자가 로그인 등을 통해 접속하게 되면 시스템은 마스터 **파일 디렉터리(MFD)를 먼저 탐색**한다.
    - **MFD**는 사용자 이름이나 계정 번호로 색인되어 있고, 각 엔트리는 그 사용자의 UFD를 가리키고 있다.
    - 그 후 사용자가 특정한 파일을 시스템에 제시하면 그 UFD 디렉터리 밑에서만 탐색한다.
        - UFD 내에서 파일 이름이 유일하면 → 다른 사용자들이 동일한 이름의 파일을 가져도 상관 없다.
    - 파일 생성 시 운영체제는 그 이름의 다른 파일이 이미 존재하는지를 확인하기 위해서 UFD만을 검색하기만 하면 된다.
    
- 이렇게 되려면 시스템은 각 사용자를 위한 UFD를 만들고 없앨 수 있어야 한다.
    - 이를 위해서는 적정한 사용자 이름과 회계 정보를 가지고 특수 시스템 프로그램을 수행한다.
    - 이 프로그램은 새로운 UFD를 생성하고 MFD에 그 항을 추가한다.

- 2단계 디렉터리 구조는 파일 이름의 충돌은 어느정도 해결하였으나 새로운 문제점이 제기된다.
    - 이 구조에서는 한 사용자의 UFD를 다른 사용자가 액세스할 수 없으므로 장점이 되지만
    - 두 사용자가 한 파일을 공유해서 사용해야 하는 경우는 문제가 발생한다.
    
    *⇒ 서로가 자신의 UFD 접근을 허용하지 않으면 공유는 불가능하다 !*
    

- ***2단계 디렉터리에서 특정 파일을 지칭하기 위해서는 사용자 이름과 파일명을 사용해서 경로명(path name)을 써야 한다.***
    - **경로명**은 모든 파일이 사용자 이름과 파일 이름을 갖는 것을 말한다.
    - 모든 시스템은 자신 소유의 디렉터리가 아닌 다른 사람의 디렉터리에 있는 파일을 지명하기 위한 구문(syntax)을 가진다.
        - userA test.txt를 userB가 접근하려면 → /userb/test.txt라고 해야 한다.

- 시스템마다 볼륨을 위해 다른 구문을 쓰기도 한다.
    - Windows의 경우, 콜론(:) 사용 → ex) C:\userb\test

- 운영체제는 어셈블러, 컴파일러, 유틸리티 루틴, 라이브러리 등의 시스템 프로그램을 일반적인 파일 형태로 가지고 있다.
    - 그러다가 사용자가 터미널에서 명령어를 넣어주면 → 운영체제는 명령 해석기로 프로그램에 자기가 방금 받은 명령을 넘겨준다.
    - 디렉터리 시스템에서 파일 이름은 현재 UFD에서 검색될 것이다. (문제 발생!!)

- 위 문제의 일반적인 해결책은 검색 절차를 약간 복잡하게 하는 것이다.
    - 시스템 파일을 가지는 특정한 사용자 디렉터리를 정의한다.
    - 시스템에 적재돌 파일 이름이 주어질 때마다, 운영체제는 먼저 현재 UFD를 검색한다.
        - 명령이 주어질 때마다 일정하게 디렉터리를 탐색하는 순서 ⇒ **탐색 경로**

- 탐색 경로는 수시로 변경할 수 있는데 UNIX와 Windows 시스템이 이 방법을 사용한다.

### 13.3.3 트리 구조 디렉터리

> 여러 단계로 확장하는 일반적인 방법이 임의의 높이를 갖는 **트리(tree) 구조**이다.
> 

![image](https://user-images.githubusercontent.com/87460638/236998167-29c11d36-2406-424d-8386-8597482419bb.png)

- 이 구조는 일반 사용자들에게 자신의 서브디렉터리를 얼마든지 만들 수 있도록 해준다.

- 트리는 가장 일반적인 디렉터리 구조이다.
    - 최상위에 하나의 루트 디렉터리가 존재하며,
    - 시스템 내의 모든 파일은 고유한 경로명을 가진다.

- 디렉터리(or 서브디렉터리)는 그 하부에 다시 디렉터리나 파일을 가질 수 있다.
    - 디렉터리 각 항목은 한 비트를 사용하여 그 항목이 나타내는 파일이 일반 파일(0)인지 디렉터리 파일(1)인 지를 구분한다.

- 디렉터리를 생성하거나 삭제하기 위해서는 특별한 시스템 콜을 한다.
    - 이 경우 운영체제는 디렉터리를 위한 또 하나의 파일 형식을 구현한다.

> 각 프로세스는 **현재 디렉터리(current directory)**를 가지고 있다.
> 
- 현재 디렉터리 안에는 **사용자가 현재 관심이 있는 대부분의 파일이 들어있을 것**이다.
    - 따라서 파일의 참조가 일어나면 현재 디렉터리를 먼저 검색한다.
    - 현재 디렉터리에 없는 파일을 참조하려면 
    → 탐색 경로 사용 or 그 파일이 있는 디렉터리로 먼저 가야 한다.

- 사용자 로그인 셀의 시작 현재 디렉터리는 사용자 작업이 시작하거나 사용자가 로그인했을 경우 설정되는 곳이다.
    - 운영체제는 사용자의 항목을 검색하기 위해서 계정 파일을 검색한다.
    
- **계정 파일**은 사용자의 현재 디렉터리를 가리키는 포인터를 포함하고 있다.
    - 이 포인터가 사용자의 현재 디렉터리를 나타내는 지역 변수에 복사된다.
    - 그 셀로부터 다른 프로세스들이 복제될 수 있고,
    - 보통 복제된 프로세스의 현재 디렉터리는 부모 프로세스를 따른다.

> *경로명에는 **절대 경로명**과 **상대 경로명**이 있다.*
> 
- 절대 경로명는 **루트에서부터 지정된 파일까지**의 경로가 명시된 것을 말한다.
- 상대 경로명은 **현재 디렉터리를 기준으로 목적하는 파일까지**의 경로를 지정하는 것을 말한다.

- 사용자에게 자신의 서브디렉터리를 만들도록 허용하는 것은 사용자가 임의의 방식으로 파일들을 구성할 수 있도록 허용하는 것이다.
    - 이러한 구조는 주제에 따라서 다른 파일을 포함하거나 정보의 유형에 따라 개별적인 디렉터리를 생성할 수 있다.

> 트리 구조의 흥미로운 문제는 *삭제 문제*이다.
> 
- 제거 대상 디렉터리가 파일들이나 서브디렉터리들로 아직 채워져 있다면 삭제는 2가지 방법 중 하나를 택할 수 있다.
    1. 재귀적으로 적용하여 서브디렉터리의 파일까지 모두 삭제한다.
    2. UNIX rm과 같은 옵션으로 파일을 삭제한다.

- 트리 구조 디렉터리 시스템에서 사용자는 자신의 파일 뿐만 아니라 다른 사용자의 파일도 접근할 수 있다.

### 13.3.4 비순환 그래프 디렉터리

> **비순환 그래프(acyclic graph)**는 디렉터리들이 서브디렉터리들과 파일들을 공유할 수 있도록 허용하는 구조이다.
> 
- 똑같은 파일이나 서브디렉터리가 서로 다른 서브디렉터리에 있을 수 있다.
- 즉, 사이틀이 없는 그래프인 비순환 그래프는 **트리 구조 디렉터리 방식을 일반화한 것**이다.

![image](https://user-images.githubusercontent.com/87460638/236998213-589dffb4-6793-49f0-a7d5-12ba6f4b9c8c.png)

> *공유를 위해 디렉터리나 파일을 복사하면 안된다.*
> 
- 공유 파일(or 디렉터리)은 두 개의 복사본과 다르다.
    - 두 개의 복사본이 있으면 → 한 복사본은 다른 복사본에 영향을 미치지 않는다.
- 물리적으로 한 파일을 공유함으로써 하나의 파일에 가해진 변경을 다른 사용자가 즉시 볼 수 있다.
    - 이러한 공유는 서브디렉터리에서 특히 중요하다.
    - 한 사람이 공유되고 있는 디렉터리에 파일을 만들거나 지우면 
    → 그것이 다른 모든 공유하고 있는 서브디렉터리에 자동으로 반영된다.

> 공유 파일(공유 디렉터리)은 여러가지 방법으로 구현된다.
> 
- 일반적인 방법은 **링크(link)**라 불리는 새로운 디렉터리 항목을 만드는 것이다.
    - 링크는 다른 파일이나 서브디렉터리를 가리키는 포인터이다.
    - 링크는 절대 혹은 상대 경로명으로 구현될 수 있다.
    - 실제 파일에 대한 경로 이름을 사용함으로써 링크를 **해석(resolve)**한다.

- 또 다른 방법은 디렉터리들이 동일한 항목 내용을 복사해서 가지고 있는 방법이다.

> 비순환 그래프 디렉터리는 트리 구조보다 융통성 있는 대신 더 복잡하다.
> 
- 파일은 여러 개의 절대 경로명을 가질 수 있다.
    - → 다른 파일 이름이 같은 파일을 가리킬 수 있다 !
    - *이 문제는 가명 문제와 유사하다.*

- 또 다른 문제는 삭제 시의 문제이다.
    - 남아 있는 파일 포인터들이 실제 디스크 주소를 포함하고 있고,  그 공간이 다른 파일에 재사용된다면 
    → 남아 있는 포인터는 다른 파일의 내용을 가리키게 될 수 있다 !

> ***심볼릭 링크로 공유를 구현하는 시스템에서는 이러한 상황을 다소 쉽게 해결할 수 있다.***
> 
- 그런데 이 링크는 살아있으면서 이 링크가 가리키는 파일이 지워지면
    - → 이 링크는 존재하지 않는 파일의 이름을 가리키는 링크가 된다.
    - 이러한 링크는 탐색하고 삭제할 수 있지만, 파일마다 연관된 링크의 목록을 유지하지 않으면, 이 탐색에 소모되는 비용이 커지는 단점이 있다.
    - 또는 그 그 링크에 대한 접근이 이루어질 때까지 링크를 내버려 두다가 접근할 때, 링크가 가리키는 파일이 존재하지 않는 것을 알아내고 그 링크를 해석하는 것은 잘못된 파일을 접근하는 것처럼 실패하게 된다.

> 삭제에 관한 또 다른 방법은 ***모든 참조가 지워질 때까지 원본 파일을 보존하는 것이다.***
> 
- 이 방법을 구현하기 위해서 파일에 대한 마지막 참조가 삭제되었는지 판단할 수 있는 방법이 필요하다.
- 디렉터리 항목의 링크나 복사가 형성된다면
    - → 새로운 항목이 파일 참조 리스트에 추가된다.
- 만약 파일 참조가 비어있다면
    - → 원본 파일은 삭제된다.

- UNIX 운영체제는 **하드 링크**에 대해서는 파일 정보 블록에 참조 계수를 유지하면서 이러한 방식을 취하고 있다.

### 13.3.5 일반 그래프 디렉터리

![image](https://user-images.githubusercontent.com/87460638/236998251-7c8b0f78-a109-4ba2-9e7a-1c63f4ae91f0.png)

> **가비지 컬렉션**은 전체 파일 시스템을 검색하고, 접근 가능한 모든 것을 표시한다.
> 
- 가비지 컬렉션은 그래프에 순환이 생길 경우에만 필요하기 때문에 비순환 그래프보다 다루기 훨씬 쉽다.

- 새로운 링크가 디렉터리 구조에 추가될 때 순환이 생기지 않도록 하는 것이 주된 일이다.
    - 그렇다면 새로운 링크가 순환을 만드는지 알 수 있을까 ? 
    → 디렉터리를 탐색하는 도중 링크는 검색하지 않는 것이다 !
    - 순환도 피할 수 있고 추가적인 오버헤드도 발생하지 않는다.

## 13.4 보호

> ***정보가 컴퓨터 시스템에 저장되어 있을 때, 물리적인 손상(신뢰성의 문제)으로부터 그리고 부적절한 접근(보호의 문제)으로부터 안전하길 원한다.***
> 
- 신뢰성은 일반적으로 파일의 복사본에 의해 제공된다.
    - 많은 컴퓨터는 파일 시스템이 사고로 파괴될 경우를 대비해 규칙적인 간격으로 복사본을 유지는 시스템 프로그램이 있다.

- 보호는 여러 가지 방법으로 제공될 수 있다.
    - 최신 운영체제를 실행하는 랩톱의 경우 사용자 이름 및 암호 인증을 통해 보호를 제공한다.
    - 또한 보조저장장치를 암호화하여 랩톱을 열 수 있다.
    - 방화벽으로 네트워크 액세스를 보호하여 사용 중일 때 네트워크 연결을 통해 침입하기 어렵게 만들어 보호를 제공한다.

### 13.4.1 접근의 유형

> ***보호 기법은 가능한 파일 접근 유형을 제한함으로써 통제된 접근을 제공한다.***
> 
- 여러 요인에 의해 접근이 허용되거나 거부된다.
    - 그 중 하나가 ***요구되는 접근 유형***이다.
        - 읽기, 쓰기, 실행, 추가, 삭제, 리스트, 속성 변경 등

### 13.4.2 접근 제어

> ***가장 일반적인 방법은 사용자의 신원에 따라 특정 파일에 대한 접근 허용 여부를 결정하는 것이다.***
> 
- 여러 사용자는 각 파일과 디렉터리에 대해 서로 다른 접근이 필요할 수 있다.
    - 신원에 기반한 접근을 구현하는 가장 일반적인 방법은 각 파일과 디렉터리에 접근 제어 리스트(ACL)를 연관해 두는 것이다.
    - 이 리스트는 이 파일을 누가 어떠한 연산을 위해 사용할 수 있는지를 기술한다.
    - 또한, 사용자가 특정 파일에 대한 접근을 요청할 때, 운영체제는 그 파일의 접근 리스트를 검사하여 허용 여부를 결정한다.

- 이 접근 방법은 복잡한 접근 방법을 가능하게 하는 장점이 있다.
- 접근 리스트의 주요 문제점은 그 ***리스트의 길이***이다.
    - 만약 모든 사람에게 읽기 접근 허용하려면, 모든 사용자가 읽기 접근을 가지도록 열거해야 한다. → 두 가지 원치 않는 결과를 얻는다.
        1. 시스템 사용자의 리스트를 미리 알 수 없다.
        2. 디렉터리 항목이 가변 크기가 되어 결과적으로 더욱 복잡한 공간 관리 문제가 발생한다.

- 위 문제점은 ***접근 리스트를 간소화함***으로써 해결할 수 있다.
    - 접근 리스트의 길이를 간결하게 하기 위해 많은 시스템은 모든 사용자를 3가지 부류로 분류한다.
        - **소유자** = 파일을 생성한 사용자
        - **그룹** = 파일을 공유하여 파일에 대한 유사한 접근을 해야 하는 사용자들의 집합
        - **기타** = 시스템에 있는 모든 다른 사용자들

- 가장 일반적인 방법은 접근 제어 리스트를 구현하기 쉬운 ***소유자, 그룹, 기타를 결합***하는 것이다.
    - 이 기법이 적절하게 동작하려면, 허가 및 접근 리스트가 엄격하게 통제되어야 한다.
    - 통제는 여러 방법으로 실행될 수 있다. ~~(17.6.2절에 논의함)~~

- 제한된 보호 분류에서는 보호를 정의하기 위해 3개의 필드만 필요하다.
    - 각 필드는 비트들의 집합으로 구성되고,
    - 각 비트는 접근을 허용하거나 금지한다.

- *결합식 기법의 한 가지 난점은 사용자 인터페이스이다.*
    - 사용자는 언제 한 파일에 대해 선택 사항인 ACL 허가를 설정할지를 알릴 수 있어야 한다.
    - Windows 사용자는 보통 GUI를 통해 접근 제어 리스트를 관리한다.
    
- *또 한가지 난점은 허가와 ACL이 서로 상충할 때 우선권을 부여하는 일이다.*

### 13.4.3 다른 보호 방법

> *파일 보호를 위해 사용될 수 있는 또 다른 방법은 각 파일에 접근할 때, **암호(password)를 요구하는 것이다.***
> 
- 암호가 무작위로 선택되고 자주 변경된다면 이 기법은 파일 접근의 암호를 알고 있는 사람으로 제한하는 데 효과적일 것이다.

- 그러나 이러한 방법은 몇 가지 단점이 있다.
    1. 파일마다 독자적인 암호를 가지면 기억해야 할 암호의 수가 너무 많다.
    2. 모든 파일에 대해 하나의 암호를 쓸 경우에는 하나만 알려지면 모든 파일 접근이 가능하게 된다.

- 여러 단계의 디렉터리를 가지는 구조에서는 각각의 파일의 보호뿐만 아니라 각 서브디렉터리를 보호하는 직접 보호 기능이 있어야 한다.
    - 디렉터리용 연산은 일반 파일용 연산과 다르므로 따로 보호되어야 한다.
    
- 사용자가 한 파일의 경로명을 제시하면, 그 디렉터리와 파일을 둘 다 접근할 수 있게 해야 한다.
    - 만약 한 파일이 여러 개의 경로명을 가지는 경우 → 한 사용자가 사용하는 경로명에 따라 서로 다른 액세스 권한으로 이 파일에 접근할 수 있다.

## 13.5 메모리 사상 파일

> 디스크 입출력을 메모리 참조 방식으로 대신할 수 있는데, 이러한 **메모리 사상(memory-mapping)** 이라고 불리는 접근 방식은 프로세스의 가상 주소 공간 중 일부를 관련된 파일에 할애하는 것을 말한다.
> 

### 13.5.1 기본 기법

> 파일의 메모리 사상은 프로세스의 페이지 중 일부분을 디스크에 있는 파일의 블록에 사상함으로써 이루어진다.
> 
- 접근은 일반적인 요구 페이징 과정에 따라 페이지 폴트가 발생한다.
    - 이때 그 파일 내용 중 페이지 크기만큼의 해당 부분이 파일 시스템으로부터 메모리 페이지로 읽혀 들어오게 된다.
    - 그 이후의 파일 read/write는 일반적인 메모리 액세스와 같이 처리된다.

- 메모리에 매핑된 파일에 대한 쓰기가 반드시 보조저장장치의 파일에 즉각적(동기식)으로 써지지 않는다는 것을 주의한다.
    - 일반적으로 시스템은 파일을 닫을 때만 메모리 이미지의 변경 사항에 따라 파일을 업데이트한다.
    - 메모리가 부족한 상황에서 시스템은 다른 용도로 메모리를 확보할 때 변경 사항을 잃어버리지 않도록 스왑 공간에 즉각 반영한다.
    - 파일이 닫히면 모든 메모리 사상된 데이터가 보조저장장치의 파일에 다시 쓰이고 프로세스의 가상 메모리에서 제거된다.
    
- 일부 운영체제는 특정 시스템 콜을 통해서만 메모리 사상 파일 처리를 해주고 일반적으로는 표준 파일 관련 시스템 콜을 통해 접근하도록 한다.
    - 반면 어떤 운영체제는 메모리 사상 파일을 표준으로 삼기도 한다.
    
- 여러 프로세스사 데이터 공유를 위해 메모리 사상 파일을 공유할 수도 있다.
    - 이러한 경우 한 프로세스가 공유 중인 메모리 사상 파일에 write하면 즉시 다른 모든 프로세스도 볼 수 있게 된다.
    
    ![image](https://user-images.githubusercontent.com/87460638/236998294-0deda9f1-85a7-4e89-8c0f-56ce42abf580.png)
    

- 사실 공유 메모리를 메모리 사상 파일을 이용하여 구현하는 것은 매우 자주 있는 일이다.
    - 이러한 방식은 동일한 파일을 프로세스들의 가상 주소 공간에 메모리 사상하게 함으로써 프로세스들은 공유 메모리를 사용하여 통신할 수 있다.
    - 메모리 사상된 파일은 통신하는 프로세스 사이의 공유 메모리 영역으로서 동작한다.
    
    ![image](https://user-images.githubusercontent.com/87460638/236998319-6f0a52db-949d-4ea8-ab89-438f33d45a7c.png)
    

### 13.5.2 Windows API에서 공유 메모리

- Win32 API에서 메모리 사상 파일을 이용하여 공유 메모리를 생성하는 전체적인 과정을 살펴보면,
    - 먼저 사상될 파일에 대한 **file mapping**을 생성하고,
    - 사상된 파일의 프로세스 가상 주소 공간상의 **뷰(view)**를 만든다.
    - 다른 프로세스는 파일을 오픈한 뒤 사상된 파일의 뷰를 가상 주소 공간상에 생성한다.
    - 사상된 파일은 프로세스 간의 통신을 위한 공유 메모리 객체를 나타낸다.

    ![image](https://user-images.githubusercontent.com/87460638/236998362-85ddfaf7-1be5-4e0c-b474-1768a53cfbac.png)
