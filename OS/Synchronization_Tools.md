# Chap6 Synchronization Tools

## 6.1 배경

- 앞 장 요약
    - chap3에서 프로세스 스케줄링의 역할 및 CPU 스케줄러가 프로세스 사이에서 빠르게 오가며 각 프로세스를 실행하여 모든 프로세스를 병행 실행시킨다는 것을 알았다.
    - chap4에서 병렬 실행, 즉 다른 프로세스에 속한 두 개의 명령어 흐름이 한순간에 다른 처리 코어에서 동시에 실행되는 방식을 알았다.
    - chap6에서는 프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지에 관해 알아보고자 한다.

- 유한 버퍼 문제
    - 앞서 chap3에서 말한 해결책은 공유 메모리를 사용하는 것이다.
        - (단점) 동시에 최대 `BUFFER_SIZE - 1개` 까지의 항목만을 버퍼에 저장할 수 있다.
    - 위 단점을 없애기 위해 기존 알고리즘을 수정한다고 가정하자.
        - count 라는 정수형 번수를 추가하여, 버퍼에 새 항목을 추가할 때마다 count++, 버퍼에서 한 항목을 꺼낼 때마다 count-- 를 한다.
    - 생산자를 위한 코드
        
        ![image](https://user-images.githubusercontent.com/87460638/235674132-c6cef06b-fdab-4e85-afd1-404d1a5f6e46.png)
        
    - 소비자를 위한 코드
        
        ![image](https://user-images.githubusercontent.com/87460638/235674311-ab728c6b-157a-41fc-8b91-80cc02c78f95.png)
        
    - 하지만 위 코드는 개별적으로 올바르더라도, 병행적으로 실행은 되지 않는다.
    - 부정확한 상태에 도달하는 것은 (실제로 5개의 버퍼가 채워져 있지만 4개의 버퍼가 채워져 있다는 것을 의미, count==4의 상태) 두 개의 프로세스가 동시에 변수 count를 조작하도록 허용했기 때문이다.
    - 이처럼 동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 **경쟁 상황**(race condition)이라고 한다.
    - 위와 같은 경쟁 상황으로부터 보호하기 위해서는 한순간에 하나의 프로세스만이 변수 count를 조작하도록 보장해야 한다. 이러한 보장을 위해, 우리는 **어떤 형태로든 프로세스들이 동기화되도록 할 필요가 있다.**

- 다중 코어 시스템의 대두와 더불어 다중 스레드 응용의 개발에 관한 관심이 증가하고 있다.
    - 이러한 다중 스레드 응용에서는 자원을 공유할 가능성이 매우 높은 여러 스레드가 서로 다른 처리 코어에서 병렬로 실행된다.
    - 이러한 상황에서 경쟁상황은 더 빈번하게 발생할 수 있어, 스레드들이 동기화되도록 할 필요가 있다.

## 6.2 임계구역 문제

- 프로세스 동기화에 관한 논의는 임계구역 문제라고 불리는 문제로부터 시작한다.

- **임계구역 문제**는 프로세스들이 데이터를 협력적으로 공유하기 위해 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것이다.
    - 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가를 요청해야 한다.
    - 이러한 요청을 구현하는 코드부분을 **진입 구역**(entry section)이라고 한다.
    - 임계구역 뒤에는 **퇴출 구역**(exit section)이 따라올 수 있다.
    - 코드의 나머지 부분들은 총칭하여 **나머지 구역**(remainder section)이라고 한다.
    
    ![image](https://user-images.githubusercontent.com/87460638/235674389-8f19ceea-9986-487c-9f32-491ed5bf8473.png)

- 임계구역 문제에 대한 해결안 요구 조건 3가지
    - **상호 배제**
    : 프로세스 $P_i$ 가 자기의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.
    - **진행**
    : 임계구역에서 실행되는 프로세스가 없고 일부 프로세스가 이 임계구역으로 진입하려고 한다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 누가 이 임계구역으로 진입할 수 있는지를 결정하는 데 참여할 수 있다. 이때 이 선택은 연기될 수 없다.
    - **한정된 대기**
    : 프로세스가 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.

- 임의의 한순간에 많은 커널 모드 프로세스들이 운영체제 안에서 활성화될 수 있다.
    - 그 결과 운영체제를 구현하는 코드(커널 코드)는 경쟁 조건이 발생하기 쉽다.

![image](https://user-images.githubusercontent.com/87460638/235674445-906a3b37-370f-4f6e-9d0c-e73cbb672fc5.png)

- 경쟁 조건이 발생하기 쉬운 커널 자료구조는 **메모리 할당을 관리하는 자료구조, 프로세스 리스트를 유지하는 자료구조, 인터럽트 처리를 위한 자료구조** 등이 있다.
    - 이러한 경쟁 조건이 발생하지 않도록 보장하는 것은 커널 개발자의 책임이다.

- 임계구역 문제 해결법
    - (단일 코어 환경) 공유 변수를 수정하는 동안 인터럽트가 발생하는 것을 막는 것
    - (다중 처리기 환경) 단일코어 해결법은 적용할 수 없다.
        - 인터럽트 비활성화 시 시간이 많이 걸릴 수 있다. 또한 메시지 전달은 각 임계구역으로의 진입을 지연시키고 시스템 효율성을 떨어뜨린다.

- 운영체제 내에서 임계구역을 다루기 위해서 **선점형 커널과 비선점형 커널**의 접근법이 사용된다.
    - **선점형 커널**은 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다.
    - **비선점형 커널**은 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을 빠져나갈 때까지 or 봉쇄될 때까지 or 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.
    
- 비선점형 커널보다 선점형 커널을 선호하는 이유
    - **커널 모드 프로세스가 대기 중인 프로세스에 처리기를 양도하기 전에 오랫동안 실행할 위험이 적기 때문에** 선점형 커널이 더 응답이 민첩할 수 있다.

## 6.3 Peterson의 해결안

- 임계구역에 대한 고전적인 소프트웨어 기반 해결책으로 Peterson의 해결안이 있다.
    - 현대 컴퓨터 구조가 기계어를 수행하는 방식이기 때문에 이 해결안이 구조에서 올바르게 실행된다고 보장할 순 없다.
    - 그러나 임계구역 문제를 해결하기 위한 좋은 알고리즘적인 설명을 제공할 뿐만 아니라 상호 배제, 진행, 한정된 대기의 요구 조건을 중점으로 다루는 소프트웨어를 설계하는 데 필요한 복잡성을 잘 설명하기 때문에 이 해결책이 제시된다.
    
- **Peterson의 해결안**은 임계구역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다.
    - 프로세스는 $P_0$ 과 $P_1$로 번호를 매긴다.

- Peterson의 해결안은 두 프로세스가 두 개의 데이터 항목을 공유한다.
    - `turn` = 임계구역으로 진입할 순번
    - `flag` = 프로세스가 임계구역으로 진입할 준비가 되었다는 것을 나타낸다.

![image](https://user-images.githubusercontent.com/87460638/235674515-bb2dd03c-d0ce-4445-a99f-dfebba9f24ae.png)
![image](https://user-images.githubusercontent.com/87460638/235674561-60a27ec4-be1e-4505-ab3d-817dce6ecd4c.png)

- Peterson의 해결안 동작 설명
    - 임계구역으로 진입하기 위해서는 Pi는 먼저 flag[i]를 참으로 만들고, turn을 j로 지정한다.
    - 이렇게 함으로써 $P_i$는 $P_j$가 임계구역으로 진입하기를 원한다면 진입 가능하다는 것을 보장한다.
    - 만일 두 프로세스가 동시에 진입하기를 원한다면 진입 turn은 거의 동시에 i와 j로 지정될 것이다.
    - 이 때의 경우 turn의 궁극적인 값이 둘 중 누가 먼저 임계구역으로 진입할 것인가를 결정한다.
    - flag[j]가 false($P_j$가 나머지 구역에서 수행)가 되거나 turn이 i($P_j$는 준비 완료됐고, $P_i$가 진입구역에서 대기하고 있음)일 경우 Pi는 임계구역에 들어갈 수 있다.
    
- Peterson의 해결안이 임계구역의 문제를 해결하기 위해선 요구조건 3가지를 만족해야 한다.
    - **상호 배제** 
    : flag[2]와 turn 변수에 의해서 하나의 프로세스만 Critical Section에서 연산을 수행할 수 있음으로 Mutual Exclusion는 지켜진다.
    - **진행**
    : 각 프로세스가 자신이 Critical Section을 수행할 동안 while문에서 다른 프로세스를 유한하게 대기하도록 만드는 방법을 통하여 Progress를 지킬 수 있다.
    - **한정된 대기**
    : 각 프로세스들은 Critical Section에 진입하려는 요청을 한 후부터 다른 프로세스가 Critical Section을 수행하는 동안 유한하게 대기함으로 bounded waiting 또한 지켜진다.

- Peterson의 해결안은 최신 컴퓨터 아키텍처에서 작동한다고 보장되지 않는다.
    - 주된 이유는 시스템 성능을 향상하기 위해 프로세서 또는 컴파일러가 종속성이 없는 읽기 및 쓰기 작업을 재정렬 할 수 있기 때문이다.

## 6.4 동기화를 위한 하드웨어 지원

- 앞서 얘기한 것처럼 소트프웨어 기반 해결책은 최신 컴퓨터 아키텍처에서 작동하지 않을 수 있다.
- 이 절에서는 임계구역 문제를 해결하기 위한 지원을 제공하는 3가지 하드웨어 명령어를 제시한다.
    - 이러한 초기 연산은 동기화 도구로 직접 사용될 수 있거나 더 추상적인 동기화 기법의 기초 형태로 사용 될 수 있다.

### 6.4.1 메모리 장벽

- 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식을 **메모리 모델**이라고 한다.
    - 일반적으로 모델은 두가지 범주 중 하나에 속한다.
    1. **강한 순서** : 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임.
    2. **약한 순서** : 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보이지 않음.

- 메모리 모델은 프로세서 유형에 따라 다르므로 커널 개발자는 공유 메모리 다중 처리기에서 메모리 변경의 가시성에 대한 어떠한 가정도 할 수 없다.
    - 이 문제를 해결하기 위해 컴퓨터 아키텍처는 메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어를 제공하여 다른 프로세서에서 실행 중인 메모리 변경 사항이 보이는 것을 보장한다.
    - 이러한 명령어를 **메모리 장벽** or **메모리 펜스**라고 한다.

- 메모리 장벽 명령어가 실행될 때, 시스템은 후속 적재 또는 저장 연산이 수행되기 전에 모든 적재 및 저장이 완료되도록 한다.
    - 따라서 명령이 재정렬되더라도 메모리 장벽은 향후 적재 or 저장 작업이 수행되기 전에 저장 작업이 메모리에서 완료되어 다른 프로세서에 보이도록 한다.

- 메모리 장벽은 매우 낮은 수준의 연산으로 간주하며 일반적으로 상호 배제를 보장하는 특수 코드를 작성할 때 커널 개발자만 사용한다.

### 6.4.1 하드웨어 명령어

- 많은 현대 기계들은 워드(word)의 내용을 검사하고 변경하거나, 두 워드의 내용을 원자적으로 교환(swap)할 수 있는, 즉 인터럽트 되지 않는 하나의 단위로서, 특별한 하드웨어 명령어들을 제공한다.
    - 특별한 명령어들을 사용하여 임계구역 문제를 상대적으로 간단한 방식으로 해결할 수 있다.
    - 명령어를 추상적으로 표현하면 `test_and_set()` 과 `compare_and_swap()` 이 있다.

`**test_and_set()**`

- `test_and_set` 은 다음과 같이 정의된다.
    - 중요한 특징은 원자적으로 실행된다는 점이다.
    - 만일 두개의 `test_and_set()` 이 동시에 실행된다면, 이들은 어떤 임의의 순서로 순차적으로 실행될 것이다.
        
        ![image](https://user-images.githubusercontent.com/87460638/235674655-1fa886ac-49d5-44ea-80a3-f5ea8f4d3da8.png)
        
- `test_and_set` 를 이용한 상호 배제 구현은 다음과 같다.

![image](https://user-images.githubusercontent.com/87460638/235674750-28161659-1f2e-4018-989f-e8aa82886619.png)

`compare_and_swap()` = **CAS**

- `test_and_set()` 명령어와 마찬가지로 두 개의 워드에 대해 원자적인 연산을 하지만 두 워드의 내용 교환에 기반을 둔 다른 기법을 사용한다.
- CAS는 3개의 피연산자를 대상으로 연산하며, 다음과 같이 정의된다.
    - 명령이 원차적으로 실행되므로, 두 개의 CAS 명령이 동시에 실행되면 임의의 순서로 순차적으로 실행된다.

![image](https://user-images.githubusercontent.com/87460638/235675604-7ef21d79-3014-47b9-ae64-f79abe349e9c.png)

> CAS를 사용하는 상호 배제는 다음과 같이 지켜질 수 있다.
> 
1. 상호배제 구조
- 구조 설명
    - `compare_and_swap` 을 호출한 첫번째 프로세스는 lock을 1로 지정
    - lock의 원래 값이 expected값과 같으므로 프로세스는 임계구역으로 들어간다.
    - `compare_and_swap` 호출은 현재 lock의 값이 기댓값 0과 같지 않기 때문에 성공하지 못한다.
    - 프로세스가 임계구역을 빠져나올 때 lock을 0으로 변경하고,
    - 다른 프로세스가 임계구역을 들어갈 수 있게 허용한다.
- 이 알고리즘은 ***상호 배제 조건은 만족시키나 한정된 대기 조건을 만족시키지 못한다.***

![image](https://user-images.githubusercontent.com/87460638/235675942-6362d426-4ca3-4ed8-919b-7da1017e3e86.png)

1. 한정된 대기 조건을 만족시키는 상호배제
- 임계구역 요구 조건을 모두 만족시키도록 다음과 같이 구현한다.
- 구조 설명
    - Pi가 임계구역에 진입하는 경우는 오직 waiting[i] == false 이든지 key == 0 이 되어야 한다.
    - lock이 0일 때에만 key가 0 이되고 lock이 1로 바뀌면서 무한 루프에서 빠져나올 수 있다.
    
    ![image](https://user-images.githubusercontent.com/87460638/235674882-2d7b661b-25bf-4ea3-90d5-5f5669b17ec2.png)

- Progress 조건이 만족함을 보이기 위해서는 위의 상호 배제 논리를 여기에도 비슷하게 사용할 수 있다.
    - 임계구역을 떠나는 프로세스는 lock을 0 또는 waiting[j]를 false 로 한다.
    - 어느 쪽이든 둘 다 임계구역으로 들어가고자 하는 프로세스를 진입하게 만들어 준다.

- 한정된 대기 조건을 만족시킴을 증명하기 위해서는 한 프로세스가 임계구역을 떠날 때 waiting 배열을 순환하면서 훑어본다는 사실을 착안하면 된다.
    - 순환하면서 조사하여 (waitign[j] == true) 이면서 위 순환 순서 중 첫 번째 프로세스가 임계구역에 들어가게 된다.
    - 따라서 임계구역에 들어가고자 하는 프로세스는 최대한 n-1 회만 양보하면 들어갈 수 있다.

### 6.4.3 원자적 변수

- 일반적으로 `compare_and_swap()` 명령어는 상호 배제를 제공하기 위해 직접 사용되지 않는다.
    - 오히려 임계구역 문제를 해결하는 다른 도구를 구축하기 위한 기본 구성요소로 사용된다.
- 그러한 도구 중 하나는 **원자적 변수**로, 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다.
    - 원자적 변수는 카운터가 증가할 때와 같이 갱신되는 동안 단일 변수에 대한 데이터 경쟁이 있을 수 있는 상황에서 상호 배제를 보장하는 데 사용될 수 있다.

- 원자적 변수를 지원하는 대부분의 시스템은 원자적 변수에 접근하고 조작하기 위한 기능뿐만 아니라 특별한 원자적 데이터 유형을 제공한다.

- 원자적 변수는 원자적 갱신을 제공하지만 모든 상황에서 경쟁 조건을 완벽히 해결하지 않는다.

- 원자적 변수는 운영체제 및 병행 응용 프로그램에서 일반적으로 사용되지만 카운터 및 시퀀스 생성기와 같은 공유 데이터 한 개의 갱신에만 제한되는 경우만 많다.

## 6.5 Mutex Locks

- 운영체제 설계자들은 임계구역 문제를 해결하기 위한 상위 수준 소프트웨어 도구들을 개발한다.
    - 가장 간단한 도구가 바로 **mutex lock**이다.

> `acquire()` : 락을 획득하는 함수
> 
> 
> `release()` : 락을 반환하는 함수
> 
> `available` : 락의 가용 여부를 표시하는 변수
> 

- 임계구역을 보호하고, 경쟁 조건을 방지하기 위해 mutex lock을 사용한다.
    - 즉, 프로세스는 임계구역에 들어가기 전에 반드시 락을 획득해야 하고 임계구역을 빠져나올 때 락을 반환해야 한다.
    - 아래와 같이 `acquire()` 함수가 락을 획득하고 `release()` 함수가 락을 반환한다.
    
    ![image](https://user-images.githubusercontent.com/87460638/235674954-b6ec9f09-580d-4526-9694-a2668789fa53.png)

- Mutex lock은 available이라는 불린 변수를 가지는데, 이 변수 값이 락의 가용 여부를 표시한다.
    - 락이 가용하면 `acquire()` 호출은 성공하고 락은 곧 사용 불가 상태가 된다.
    - 사용 불가 상태의 락을 획득하려고 시도하는 프로세스는 락이 반환될 때까지 봉쇄된다.
    
- `acquire()` 함수 정의는 아래와 같다.
    
    ![image](https://user-images.githubusercontent.com/87460638/235676338-8d9e4dd0-2b85-408f-bd69-32555a138b8f.png)
    
- `release()` 함수 정의는 아래와 같다.

    ![image](https://user-images.githubusercontent.com/87460638/235676375-7afa8857-fef0-40ae-8196-0fbec16089cd.png)

- `acquire()` 또는 `release()` 함수 호출은 원자적으로 수행되어야 한다.
    - 따라서 mutex lock은 CAS를 사용하여 구현할 수 있다.

- 지금까지 설명한 구현 방식의 단점은 바쁜 대기를 해야 한다는 것이다.
    - 프로세스가 임계구역에 있는 동안 임계구역에 들어가기 원하는 다른 프로세스들은 `acquire()` 함수를 호출하는 반복문을 계속 실행해야 한다.
    - 이러한 바쁜 대기는 다른 프로세스가 생산적으로 사용할 수 있는 CPU 주기를 낭비한다.

- 우리가 설명한 mutex lock 유형을 **스핀락(spinlock)**이라고도 한다.
    - 락을 사용할 수 있을 때까지 프로세스가 회전하기 때문이다.
    - 그러나 스핀락은 프로세스가 락을 기다려야 하고 문맥 교환에 상당한 시간이 소요될 때 문맥 교환이 필요하지 않다는 장점이 있다.
    - 최신 다중 코어 컴퓨팅 시스템에서 스핀락은 많은 운영체제에서 널리 사용된다.
    - 일반적으로 락이 유지되는 기간이 문맥 교환을 두 번(1.스레드를 대기상태로 2.대기중인 스레드를 복원) 하는 시간보다 짧은 경우 스핀락을 사용한다.

> ***락 경합(Lock Competition)***
> 
> 
> *락에 대한 경합 상태일 수도 비경합 상태일 수도 있다.*
> 
> *락을 획득하려고 시도하는 동안 스레드가 봉쇄되면 락은 **경합 상태**로 간주한다.*
> 
> *스레드가 락을 얻으려고 시도할 때 락을 사용할 수 있으면 락은 **비경합 상태**로 간주한다.*
> 
> ***높은 경합 상태의 락은 병행 실행 응용 프로그램의 성능을 전체적으로 저하한다.***
> 

### 6.6 세마포

- **세마포** S는 정수 변수로서, 초기화를 제외하고는 단지 두 개의 표준 원자적(atomical) 연산 wait()와 signal()로만 접근할 수 있다.
    - `wait()` 연산은 원래 “검사하다”를 의미하는 네덜란드어 proberen에서 **P**, 
    `signal()` 연산은 “증가하다”를 의미하는 verhogen에서 **V**라고 지어졌다.
    - `wait()` 정의는 다음과 같다.
        
       ![image](https://user-images.githubusercontent.com/87460638/235677302-dfc6f332-bf7e-4d8c-acdf-a6f2d1143d29.png)
       
    - `signal()` 정의는 다음과 같다.
        
        ![image](https://user-images.githubusercontent.com/87460638/235677345-a73e334a-7260-4ad9-9e7f-bedcbc81142a.png)
        
- `wait()`와 `signal()` 연산 시 세마포의 정수 값을 변경하는 연산은 반드시 원자적으로 수행되어야 한다.
    - 즉, 한 스레드가 세마포 값을 변경하면, 다른 어떤 스레드도 동시에 동일한 세마포 값을 변경할 수 없다.

### 6.6.1 세마포 사용법

- 운영체제는 종종 카운팅(counting)과 이진(binary) 세마포를 구분한다.
    - **카운팅 세마포**의 값은 제한 없는 영역을 갖지만 **이진 세마포**의 값은 0과 1사이의 값만 가능하다.
    - 이진 세마포는 mutex lock과 유사하게 동작한다.

- **카운팅 세마포는 유한한 개수를 가진 자원에 대한 접근을 제어하는데 사용될 수 있다.**
    - 세마포는 가용한 자원의 개수로 초기화된다.
    - 각 자원을 사용하려는 프로세스는 세마포에 `wait()` 연산을 수행하며, 이때 세마포의 값은 감소한다.
    - 프로세스가 자원을 방출할 때는 `signal()` 연산을 수행하고 세마포는 증가하게 된다.
    - 세마포의 값이 0이 되면 모든 자원이 사용중임을 나타낸다.
    - 이후 자원을 사용하려는 프로세스는 세마포 값이 0보다 커질 때까지 봉쇄된다.

### 6.6.2 세마포 구현

- 바쁜 대기를 피하기 위해 세마포 S를 대기하면서 일시 중지된 프로세스는 다른 프로세스가 `signal()` 연산을 실행하면 재시작 되어야 한다.
    - 프로세스는 `sleep()` 연산에 의해서 일시 중지되고, `wakeup()` 연산에 의하여 재시작된다. 
    ⇒ 대기상태 ↔ 준비 완료 상태
    - 그리고 프로세스는 준비 완료 큐에 넣어진다.

- 세마포를 다음과 같이 정의한다.
    
    ![image](https://user-images.githubusercontent.com/87460638/235677423-f560bf27-d911-4018-9410-f159140c8b55.png)
    
- `wait()` 연산은 다음과 같이 정의한다.
    
    ![image](https://user-images.githubusercontent.com/87460638/235677450-9cc55b27-3a7a-4bf8-8a9d-bd3833f5276c.png)
    
- `signal()` 연산은 다음과 같이 정의한다.
    
    ![image](https://user-images.githubusercontent.com/87460638/235677518-eab28aae-c21c-4306-a087-be98da64b438.png)   

- 바쁜 대기를 하는 세마포의 고전적 정의에서는 세마포의 값은 음수를 가질 수 없으나, 이처럼 구현하면 음수 값을 가질 수 있다.
    - 세마포 값이 음수일 때, 그 **절댓값**은 **세마포를 대기하고 있는 프로세스들의 수**이다.

- 대기하는 프로세스들의 리스트는 각 프로세스 제어 블록(PCB)에 있는 연결 필드에 의하여 쉽게 구현될 수 있다.

- 세마포가 원자적으로 실행되어야 한다는 것은 매우 중요하다.
    - 같은 세마포에 대해 두 프로세스가 동시에 `wait()` 와 `signal()` 연산들을 실행할 수 없도록 반드시 보장해야 한다. ⇒ 이런 상황은 임계구역 문제에 해당한다.

- 단일 처리기 환경에서는, 단순히 `wait()` 와 `signal()` 연산들이 실행되는 동안 인터럽트를 금지함으로써 간단히 해결할 수 있다.
    - 인터럽트가 금지되면, 다른 프로세스들의 명령어들이 끼어들 수 없다.
    - 따라서 인터럽트가 다시 가능해지고 스케줄러가 제어를 다시 얻을 수 있을 때까지 오로지 현재 수행되고 있는 프로세스만 실행된다.
    
- 다중 코어 환경에서는, 모든 처리 코어에서 인터럽트를 금지하여야만 한다.
    - 그렇지 않으면 다른 코어에서 실행되는 명령어들이 임의의 방법으로 서로 낑들 수 있다.
    - 모든 코어에서 인터럽트를 금지하는 매우 어려운 작업일 수 있으며 성능을 심각하게 감소시킨다.
    - 따라서 SMP 시스템은 `wait()` 와 `signal()` 연산이 원자적으로 실행되는 것을 보장하기 위하여 `compare_and_swap()`  또는 스핀락과 같은 다른 기법을 제공해야 한다.

## 6.7 모니터

- 세마포가 프로세스 간의 동기화를 위해서 편리하고 효율적으로 쓰일 수 있지만 세마포는 자칫 잘못 사용하면 발견하기 어려운 타이밍 오류를 야기할 수 있다.
    - 이러한 타이밍 오류들은 특정 실행 순서로 진행되었을 때만 발생하고 이러한 순서가 항상 일어나지 않는다.

- 일어날 수 있는 문제점을 예시로 나열해 보자.
    - 프로그램의 세마포에 대한 `wait()` 와 `signal()` 연산의 순서가 뒤바뀌었다고 가정하자.
    ⇒ 여러 프로세스가 동시에 임계구역 안에서 실행될 수 있어 상호 배제 요구 조건을 위반한다.
    - 프로그램이 `signal(mutex)`를 써야 할 곳에 잘못해서 `wait(mutex)`를 썼다고 가정하자.
    ⇒ 세마포를 사용할 수 없으므로 프로세스는 두 번째 `wait()` 호출에서 영구적으로 봉쇄된다.
    - 프로세스가 `wait(mutex)`나 `signal(mutex)` 또는 둘 다를 빠트렸다고 가정하자.
    ⇒ 상호 배제 요구 조건을 위반하거나 프로세스가 영원히 봉쇄된다.

- 위 예처럼 세마포 또는 mutex lock을 이용하여 임계문제를 해결할 때 프로그래머가 세마포를 잘못 사용하면 다양한 유형의 오류가 너무나도 쉽게 발생할 수 있음을 알 수 있다.
    - 이러한 오류를 처리하기 위한 한 가지 전략은 간단한 동기화 도구를 통합하여 고급 언어 구조물을 제공하는 것이다.
    - 근본적인 고급 언어 구조물 중 하나인 **모니터** 형을 알아보자.

### 6.7.1 모니터 사용법

- **추상화된 데이터 형**(**ADT**, abstract data type)은 데이터와 이 데이터를 조작하는 함수들의 집합을 하나의 단위로 묶어 보호한다.
    - 이때 함수의 구현은 ADT의 특정한 구현과 독립적이다.
    
- **모니터 형은 모니터 내부에서 프로그래머가 정의한 상호 배제가 보장되는 일련의 연산자 집합을 포함하는 ADT이다.**
    - 모니터 형은 인스턴스의 상태를 정의하는 변수들과 이를 조작할 수 있는 프로시저 또는 함수들의 본체도 같이 포함하고 있다.

- 모니터 형의 표현은 다른 프로세스들이 직접 사용할 수 없다.
    - 모니터 내에 정의된 함수만이 오직 모니터 내에 지역적으로 선언된 변수들과 형식 매개변수들에만 접근할 수 있다.
        
        ![image](https://user-images.githubusercontent.com/87460638/235677651-9f9a7a86-90e6-4d3f-923c-26b487a778f1.png)

- **모니터 구조물은 모니터 안에 항상 하나의 프로세스만이 활성화되도록 보장해 준다.**
    - 모니터의 계략도
        
        ![image](https://user-images.githubusercontent.com/87460638/235677708-ae290af3-bc4e-497c-98ac-f9112d2fea4d.png)
        
    - 그러나 지금까지 정의한 모니터 구조물은 어떤 동기화 기법을 모델링하는 데에는 충분한 능력을 제공하지 않는다.
    - 이를 위해 condition이라는 구조물로 동기화 기법들을 제공해 보자.
    - 자신의 동기화 기법을 작성할 필요가 있는 프로그래머는 하나 이상의 condition 형의 변수를 정의할 수 있다.
        - condition형 변수에 호출될 수 있는 연산은 오직 wait()와 signal()이다.
    
    ```java
    condition x, y;
    ```
    
    - 조건 변수를 갖는 모니터
        
        ![image](https://user-images.githubusercontent.com/87460638/235677756-e0e0b176-fc24-4204-a7a0-77ff0c8e0e44.png)

- 일시 중지된 스레드 Q가 실행을 재개하도록 허용한다면, signal 을 보낸 스레드 P는 반드시 대기해야 한다.
→ 그렇지 않으면, P와 Q는 모니터 안에서 동시에 활성화된다.
    - 두 프로세스는 개념적으로 그들의 실행을 계속할 수 있다는 사실에 유의해야 한다.
    - 여기에 두가지 가능성이 존재한다.
    1. **Signal and wait** : P는 Q가 모니터를 떠날 때까지 기다리거나, 다른 조건을 기다린다.
    2. **Signal and continue** : Q는 P가 모니터를 떠날 때까지 기다리거나, 다른 조건을 기다린다.

- 위 옵션 뿐만 아니라 이들의 절충안도 존재한다.
: 스레드 P가 signal() 연산을 수행하면 즉시 모니터를 떠나고 Q가 즉시 재개된다.

### 6.7.2 세마포를 이용한 모니터의 구현

- 각 모니터마다 mutex라는 이진 세마포가 정의되고 그 초기 값은 1이다.
- 프로세스는 모니터로 들어가기 전에 wait(mutex)를 실행하고 모니터를 나온 후에 signal(mutex)을 실행해야 한다.

- 모니터 구현 시 `signal-and-wait` 기법을 사용한다.
    - Signaling 프로세스는 실행 재개되는 프로세스가 모니터를 떠나는지 아니면 `wait()` 할 때까지 그 자신이 다시 기다려야 하므로 next라는 이진 세마포가 추가로 필요하게 되고 0으로 초기화된다.
    - Signaling 프로세스는 자신을 중단시키기 위해 next를 사용할 수 있다.
    - 정수형 변수 next_count에서도 next에서 일시 중지 되는 프로세스의 개수를 세기 위해 제공된다.
    - 따라서 각 외부 프로시저 F는 아래로 대체된다.
    
    ![image](https://user-images.githubusercontent.com/87460638/235677877-55b62b84-1f3d-422f-983e-2d6c7de72845.png)
    
- 조건 변수를 세마포로 구현하는 방법
    - 각 조건 x 마다 x_sem 이라는 이진 세마포와 x_count 라는 정수형 변수를 도입하고, 초기값을 0으로 준다.
    - `x.wait()` 연산은 다음과 같이 구현할 수 있다.
        
        ![image](https://user-images.githubusercontent.com/87460638/235678049-638c06bd-aa85-4665-8deb-8a2c98fe1551.png)
        
    - `x.signal()` 연산은 다음과 같이 구할 수 있다.
        
        ![image](https://user-images.githubusercontent.com/87460638/235678947-22cfea2c-2d97-4251-b65e-9bae4501d773.png)
        
### 6.7.3 모니터 내에서 프로세스 수행 재개

❓조건 변수 x에 여러 프로세스가 일시 중지 되어 있을 때 어떠한 프로세스를 수행 재개시킬 것인가??

🅰️ 질문에 대한 가장 간단한 방법은 FCFS 순이다. 하지만 많은 경우 이러한 간단한 스케줄링 기법은 충분하지 않다.

- 이를 위해서 아래와 같은 형식의 **conditional-wait 구조**를 사용할 수 있다.
    - 이 구조물은 `x.wait(c)` 형태를 가진다.
    - 여기서 c는 정수이고, **우선순위 번호**라고 불리며 일시 중지 되는 프로세스의 이름과 함께 저장된다.
    - 즉, x.signal()이 수행되면 가장 작은 우선순위 번호를 가진 프로세스가 다음번에 수행 재개 된다.

> *ex) ResourceAllocator 모니터*
> 
> 
> 이 모니터는 한 개의 자원을 여러 프로세스 사이에 할당해 준다. 각 프로세스는 자원을 할당받기를 원하면 그 자원을 사용할 최대 시간을 지정한다. 모니터는 이 중 가장 적은 시간을 희망한 프로세스에 자원을 할당해 준다. 이 자원을 액세스하려는 프로세스는 아래의 순서를 따라야 한다.
> 
> ![image](https://user-images.githubusercontent.com/87460638/235678198-fbce4b7c-2eef-41df-b6ed-6a61fe3e993a.png)
> 

- time을 사용해서 한 개의 자원을 접근하는데 무리없이 동작하는 것 처럼 보이지만 사실 다음과 같은 문제가 발생할 수 있다.
    - 프로세스가 자원에 대한 허락을 받지 않고 자원을 액세스 할 경우
    - 프로세스가 자원에 대한 허락을 받은 다음 그 자원을 방출하지 않을 경우
    - 프로세스가 자원에 대한 허락을 받지 않았는데도 그 자원을 방출할 경우
    - 프로세스가 자원에 대한 허락을 받은 다음 방출하지 않은 상태에서 또 그 자원을 요청할 경우
- 사실 위와 동일한 문제들은 모니터를 사용할 때 뿐만 아니라 세마포를 사용할 때도 동일하게 발생한다.
    - 이 문제를 해결하기 위해서 **자원 액세스 연산 자체를 ResourceAllocator 모니터 내부에 두는 방법**이 있고, 프로세스들이 올바른 순서를 지키도록 보장하기 위해서 **ResourceAllocator 모니터와 모니터가 관리하는 자원을 사용하는 모든 프로그램을 검사**하는 방법이 있다.

## 6.8 라이브니스

- **라이브니스**는 프로세스가 실행 수명주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야 하는 일련의 속성을 말한다.
    - 즉, 프로세스가 lock을 얻기 위해 무기한 대기하는 것은 “라이브니스 실패”의 한 예이다.

- 다양한 형태의 라이브니스 실패가 존재한다.
- 그러나 모두 성능과 응답성이 나쁜 것이 특징이다.
- 라이브니스 실패의 매우 간단한 예는 무한 루프이다.
- 즉, Mutex lock 및 세마포와 같은 도구를 사용하여 상호 배제를 제공하려는 노력은 종종 병행 프로그래밍에서 이러한 실패로 이어질 수 있다.

### 6.8.1 교착 상태 (Deadlock)

- 대기 큐를 가진 세마포 구현은 두 개 이상의 프로세스들이, 오로지 대기 중인 프로세스들 중 하나에 의해서만 야기될 수 있는 `signal()` 연산을 무한정 기다리는 상황이 발생할 수 있다.
    - 이런 상태에 도달했을 때, 이들 프로세스들을 **교착 상태(deadlock)**라고 한다.

- 한 집합 내의 모든 프로세스가 그 집합 내의 다른 프로세스만이 유발할 수 있는 이벤트를 기다릴 때, 이 프로세스들의 집합이 교착 상태에 있다고 말한다.
    - 우리가 여기서 주로 관심을 두고 있는 “이벤트”들은 mutex lock과 세마포 같은 자원의 획득과 방출이다.

### 6.8.2 우선순위 역전

- 높은 우선순위 프로세스가 현재 낮은 우선순위 프로세스 또는 연속된 낮은 우선순위 프로세스들에 의해 접근되고 있는 커널 데이터를 읽거나 변경할 필요가 있을 때 스케줄링의 어려움이 생기게 된다.
    - 통상 커널데이터는 락에 의해 보호되기 때문에 낮은 우선순위 프로세스가 자원의 사용을 마칠 때까지 높은 우선순위 프로세스가 기다려야 한다.
    - 낮은 우선순위 프로세스가 또 다른 높은 우선순위 프로세스에 의해 선점되는 경우에 상황은 더욱 복잡해진다.
    - 이러한 경우 낮은 우선순위 프로세스는 계속 기다려야만 한다.
    - 이 라이브니스 문제는 **우선순위 역전(priority inversion)**문제로 알려져 있다.

- 통상 우선순위 역전 문제는 **우선순위 상속 프로토콜(priority-inheritance protocol)**을 구현하여 해결한다.
    - 우선순위 상속 프로토콜의 하나의 예시로서, 더 높은 우선순위 프로세스가 필요로 하는 자원에 접근하는 모든 프로세스는 문제가 된 자원의 사용이 끝날 때까지 더 높은 우선순위를 상속받는다.
    - 자원 사용이 끝나면 원래 우선순위로 되돌아간다.

## 6.9 평가

- 일반적으로 하드웨어 솔루션은 매우 낮은 수준으로 간주하며 mutex lock과 같은 다른 동기화 도구를 구성하기 위한 기초로 사용된다.
    - 그러나 최근 락 오버헤드 없이 경쟁 조건으로부터 보호하는 **락 없는 알고리즘**을 구현하기 위해 CAS 명령을 사용하는데 중점을 두고 있다.
    - 이러한 락 없는 솔루션은 오버헤드가 낮고 확장성이 있기 때문에 인기를 얻고 있지만 알고리즘 자체는 개발 및 테스트가 어려운 경우가 많다.

- CAS 기반 접근 방식은 낙관적인 접근법으로 간주되고, locking 기반 접근 방식은 비관적 전략으로 간주된다.

- 다양한 경합 부하에서 CAS 기반 동기화와 기존 동기화 간의 성능 차이와 관련된 일반적인 규칙
    - **경합 없음** : 두 옵션 모두 일반적으로 빠르지만 CAS 보호는 기존 동기화보다 다소 빠를 수 있다.
    - **적당한 경합** : CAS 동기화는 기존 동기화보다 빠를 것이고 아마도 훨씬 빠르게 동작할 것이다.
    - **심함 경합** : 경합이 치열한 상황에서는 기존 동기화가 기본적으로 CAS 기반 동기화보다 빠르다.
    
- 경쟁 조건을 해결하기 위한 기법의 선택은 시스템 성능에도 큰 영향을 줄 수 있다.
    - 일반적으로 mutex lock은 세마포보다 간단하고 오버헤드가 적으며, 임계구역에 대한 접근을 보호하는 용도로 이진 세마포보다 선호된다.
    - 일반적으로 한정된 수의 자원에 대한 접근을 제어하는 것과 같은 일부 용도의 경우, mutex lock보다 카운트 세마포가 더 적합하다.

- 모니터와 조건 변수와 같은 고급 도구의 매력은 단순성과 사용 편의성으로부터 나온다.

- 다행스럽게도 병행 프로그래밍의 요구 사항을 해결하는 확장 가능하고 효율적인 도구를 개발하기 위한 많은 연구가 진행되고 있다. 이는 다음과 같다.
    - 더 효율적인 코드를 생성하는 컴파일러 설계
    - 병행 프로그래밍을 지원하는 언어 개발
    - 기존 라이브러리 및 API의 성능 향상
