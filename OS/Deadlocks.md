## Intro
- 다중 프로그래밍 환경에서 여러 스레드가 한정된 자원을 사용한다.
    - 이때, 한 스레드가 자원을 요청하면 나머지 스레드는 대기상태로 들어간다.
    - 여기서 대기 중인 스레드들이 다시는 그 상태를 변경시킬 수 없는 상태를 **교착 상태**라고 한다.

- 몇몇 응용들은 교착 상태가 일어날 가능성이 있는 프로그램을 구별할 수 있지만, 보통 운영체제들은 교착 상태 예방 기능을 제공하지 않는다.
    - 따라서 교착 상태가 없는 프로그램을 설계하는 것은 전적으로 프로그래머의 책임으로 남는다.

## 8.1 시스템 모델

- **시스템은 경쟁하는 스레드들 사이에 분배되어야 할 유한한 수의 자원들로 구성된다.**
    - 이들 자원은 다수의 유형(or 클래스)로 분할되며, 각각 동등한 다수의 인스턴스들로 구성된다.
    - 즉, 만약 한 스레드가 어떤 자원 유형의 한 인스턴스를 요청하면, 동일 유형 자원의 임의의 인스턴스를 할당함으로써 요청이 충족된다.
    
- 스레드는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야 한다.
- **스레드는 지정된 태스크를 수행하기 위해 필요한 만큼의 자원을 요청할 수 있다.**
    - 명백히 요청된 자원의 수는 시스템에서 사용 가능한 전체 자원의 수를 초과해서는 안된다.
    - 즉, **시스템이 한 개의 네트워크 인터페이스밖에 없는데 2개를 요청할 수는 없다.**

- 정상 작동 모드에서 프로세스는 다음 순서로만 자원을 사용할 수 있다.
    1. 스레드는 자원을 **요청**한다.
    2. 스레드는 자원에 대해 작업을 **수행**할 수 있다.
    3. 스레드가 자원을 **방출**한다.

- 자원의 **요청**과 **방출**은 **시스템 콜**을 의미한다.
    - ex) 장치 `request()` `release()` , 파일 `open()` `close()` , 메모리 시스템 콜 `allocate()` `free()`

- 한 스레드가 집합 내의 모든 스레드가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 이벤트를 기다린다면, 그 스레드 집합은 교착 상태에 있다.

- 다중 스레드 응용 개발자는 반드시 교착 상태의 가능성을 염두해야 한다.
    - 락킹 도구를 사용할 때, 개발자는 락이 획득되고 방출되는 방식에 주의해야 한다.

## 8.2 다중 스레드 응용에서의 교착 상태

### 8.2.1 라이브락

- **라이브락(livelock)**은 라이브니스 장애이다.
    
    
- 교착 상태와 라이브락의 차이점
    - 교착 상태가 어떤 스레드 집합의 모든 스레드가 같은 집합에 속한 다른 스레드에 의해서만 발생할 수 있는 이벤트를 기다리면서 봉쇄되면 발생한다.
    - 라이브락은 스레드가 실패한 행동을 계속해서 시도할 때 발생한다.

- 라이브락은 **일반적으로 스레드가 실패한 작업을 동시에 재시도할 때 발생**한다.
    - 따라서 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다.

- 라이브락은 교착 상태만큼 흔히 일어나진 않지만 병행 응용 프로그램을 설계하는 데 있어 어려운 문제이다.

## 8.3 교착 상태 특성

### 8.3.1 필요조건들

- 교착 상태는 한 시스템에 다음 4가지 조건이 동시에 성립될 때 발생할 수 있다.
    1. **상호 배제**; mutual exclusion
    : **최소한 하나의 자원이 비공유 모드로 점유되어야 한다**. 비공유 모드에서는 한번에 한 스레드만이 그 자원을 사용할 수 있다. 만약 다른 스레드가 그 자원을 요청할 경우, 자원이 방출될 때까지 반드시 지연되어야 한다.
    2. **점유하며 대기**; hold-and-wait
    : 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 **점유된 자원을 추가로 얻기 위해 반드시 대기**해야 한다.
    3. **비선점**; no preemption
    : 자원을 선점할 수 없어야 한다. 즉, **자원이 강제적으로 방출될 수 없고, 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출**될 수 있다.
    4. **순환 대기**; circular wait
    : 대기하고 있는 스레드의 집합 {T0, .., Tn} 에서 T0는 T1이 점유한 자원을 대기하고, T1은 T2가 점유한 자원을 대기하고, …, **Tn은 T0가 점유한 자원을 대기**한다.
    

### 8.3.2 자원 할당 그래프

- 교착 상태는 **시스템 자원 할당 그래프**(방향 그래프)로 더욱 정확하게 기술할 수 있다.
    - 그래프는 **정점 V의 집합 + 간선 E의 집합** 으로 구성된다.
    - 정점 V의 집합은 시스템 내의 모든 활성 스레드의 집합인 T와 시스템 내의 모든 자원 유형의 집합인 R의 두 가지 유형으로 구별된다.
    
- 스레드 T로부터 자원 유형 R로의 방향 간선은 T→ R로 표현하며, **요청 간선**이라 부른다.
    - = 스레드가 자원 유형의 인스턴스를 하나 요청하는 것 ⇒ 자원을 기다리는 상태
- 자원 유형 R로부터 스레드 T로의 방향 간선은 R → T로 표현하며, **할당 간선**이라 부른다.
    - = 자원 유형의 한 인스턴스가 스레드에 할당된 것

![image](https://user-images.githubusercontent.com/87460638/235684130-7c9c63ca-b859-474e-bf40-4da4aa364934.png)

> ***그래프가 사이클(cycle)을 포함하지 않으면 시스템 내 어느 스레드도 교착 상태가 아니라는 것을 보일 수 있다. 하지만** **사이클이 존재한다고 반드시 교착 상태가 발생한 것은 아니다.***
> 

![image](https://user-images.githubusercontent.com/87460638/235684223-92542ba7-e0ae-4e04-bcae-49b7fcd562e9.png)

- 스레드 T2는 T3이 점유하고 있는 자원 R3을 기다리고, 스레드 T3은 스레드 T1 또는 T2가 자원 R2를 방출하기를 기다린다.
    - 또한 T1은 T2가 자원 R1을 방출하기를 기다린다. **이 경우 모든 스레드가 교착 상태에 있다.**
    
![image](https://user-images.githubusercontent.com/87460638/235684284-30c482ad-3227-43d3-9ae0-327fe6ffb890.png)

- 위 그림 또한 사이클을 갖지만, 프로세스 T4가 자원 유형 R2의 인스턴스를 방출한다면, T3에 자원이 할당될 수 있고, 사이클이 없어진다.
    - ***따라서 사이클은 교착 상태의 필요충분조건은 아니다.***

<aside>
📌 요약하자면, 자원 할당 그래프에 **사이클이 없다면** → 시스템은 교착 상태가 **아니다.**
반면에, 사이클이 **있다면** → 시스템은 **교착상태일수도 아닐수도 있다.**

</aside>

## 8.4 교착 상태 처리 방법

- 원칙적으로 교착 상태 문제를 처리하는 데는 다음과 같은 3가지 방법이 있다.

**✅ 문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않는 척한다.**

- 오히려 발생한 교착상태를 해결하는 데 더 많은 비용이 들 수 있으므로 **무시**하는 방법이다.
- 이 경우 교착상태가 누적되면 시스템 성능을 저하시킬 수 있기 때문에 수작업으로 다시 시작할 필요가 있다.

✅ **교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.**

- 교착 상태 예방은 앞서 언급한 **4가지 조건 중 적어도 하나가 성립하지 않도록** 하는 방법이다.
- 교착 상태 회피는 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공받고, 운영체제는 각 요청을 위해 그 스레드가 기다려야 할지 않을지를 결정할 수 있다.

✅ **시스템이 교착 상태가 되도록 허용한 다음에 복구시키는 방법이 있다.**

- 교착 상태가 발생했는지 결정하기 위해 **시스템의 상태를 조사하는 알고리즘**과 **교착 상태로부터 복구하기 위한 알고리즘**을 제공할 수 있다.

## 8.5 교착 상태 예방

- 교착 상태 4가지 필요 조건을 각각 별도로 검토하면서 접근 방식을 구체화해 보자.

### 8.5.1 상호 배제

- 상호 배제 조건이 성립되기 위해선 적어도 하나의 자원은 불가능한 자원이어야 한다.
    - 반면에, 공유 가능한 자원들은 배타적인 접근을 요구하지 않으므로, 교착 상태에 관련될 수 없다.
    
- 프로세스는 공유 가능한 자원을 위해 대기할 필요가 없다.
    - 그러나 일반적으로 상호 배제 조건을 거부함으로써 교착 상태를 예방하는 것은 불가능하다.
    - 어떤 자원들은 근본적으로 공유가 불가능하기 때문이다.

### 8.5.2 점유하며 대기

- 시스템에서 점유하며 대기 조건이 발생하지 않도록 하려면 스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해야 한다.
- 프로토콜 대안
    - 프로토콜은 각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당해야 한다.
    - 프로토콜은 스레드가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용한다.
    
    ⇒ 그러나 위에서 말한 프로토콜들은 ***자원 이용률이 낮고, 기아상태 발생***할 수 있다.
    

### 8.5.3 비선점

- 이미 할당된 자원이 선점되지 않아야 한다는 것이다.
- 이 조건이 성립되지 않을 것을 보장하기 위해, 다음의 프로토콜을 사용할 수 있다.
    - 어떤 자원을 점유하고 있는 스레드가 즉시 할당할 수 없는 다른 자원을 요청하면(즉, 스레드가 반드시 대기해야 하면), 현재 점유하고 있는 모든 자원이 선점되게 할 수 있다. 
    ⇒ 즉, 자원들이 묵시적으로 방출된다.
    
    ⇒ 위 프로토콜은 CPU 레지스터나 DB 트랜잭션처럼 그 상태가 쉽게 저장되고, 후에 복원될 수 있는 자원에 종종 적용된다. → 따라서 mutex 락과 세마포 같은 자원에는 적용할 수 없다.
    

### 8.5.4 순환 대기

- 앞서 말한 세가지 옵션은 대부분 상황에서 일반적으로 실용적이지 않다.
    - 그러나 순환 대기 조건은 필요한 조건 중 하나를 무효화하여 실용적인 해결책을 제공할 수 있다.
    
- 순환 대기 조건이 성립되지 않도록 하는 한 가지 방법은 ***모든 자원 유형에 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구***하는 것이다.
    - ex) 프로세스 1번, 2번과 자원 A, B가 있다고 하였을때, 1번은 자원 B를 점유하려 시도하고, 2번은 자원 A를 점유하려 시도하게 되면서 교착상태에 빠질 수 있습니다.

- ***순서나 계층 구조를 정하는 것 자체만으로는 교착 상태를 예방할 수 없다.***
    - 순서를 지키는 프로그램을 작성하는 것은 응용 프로그래머에게 달려 있으며, `System.identityHashCode(Object)` 메소드를 이용해 락 획득 순서를 지정하는 함수를 사용하는 전략을 채택하였다.

- ***락이 동적으로 획득될 수 있다면 락 순서를 부여한다고 해서 교착 상태 예방을 보장하지 않는다.***

## 8.6 교착 상태 회피

- 앞서 설명한 것처럼 교착 상태 예방 알고리즘은 요청 방법에 제한을 두어 교착 상태가 발생하기 위한 필요조건 중 적어도 한 가지는 성립되지 않도록 보장한다.
    - 그러나 이런 방식으로 교착 상태를 예방할 때 ***장치의 이용률이 저하***되고, ***시스템 총처리율이 감소***한다는 것이다.

- 교착 상태를 회피하는 다른 대안은 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것이다.
    - 만약 우리가 각 스레드의 요청과 방출에 대한 완전한 순서를 파악하고 있다면, 각 요청에 대해서 가능한 미래의 교착 상태를 피하고자 스레드가 대기해야 하는지 여부를 결정할 수 있다.
    - 위와 같은 결정을 하려면 시스템은 현재 요청이 충족될 수 있는지, 또는 반드시 대기해야 할 것인지를 결정하기 위해 현재 가용 자원, 현재 각 스레드에 할당된 자원, 각 스레드가 앞으로 요청하거나 방출할 자원을 고려해야 한다.

- 가장 단순하고 제일 유용한 모델은 각 스레드가 자신이 필요로 하는 각 유형의 자원마다 최대 수를 선언하도록 요구하는 것이다.
    - 각 스레드가 요청할 각 유형의 자원의 최대 수 정보를 미리 파악할 수 있다면, 우리는 시스템이 교착 상태에 들어가지 않을 것을 보장하는 알고리즘을 만들 수 있다.

- 교착 상태 회피 알고리즘은 시스템에 순환 대기 상황이 발생하지 않도록 자원 할당 상태를 검사한다.
    - 자원 할당 상태는 가용 자원의 수, 할당된 자원의 수, 스레드들의 최대 요구 수에 의해 정의된다.

<aside>
🗣️ **Linux LOCKDEP 도구**
 가능한 교착 상태를 감지하기 위해 Linux는 커널 내의 락킹 순서를 검증하는 데 사용될 수 있는 다양한 기능을 갖춘 도구인 lockdep을 제공한다. **lockdep**은 락 획득 및 해제 규칙을 기준으로 **락 획득 및 해제의 사용 패턴을 감시**하기 때문에 ***실행 중인 커널에서 활성화되도록 설계되었다.***

 lockdep은 커널에서 코드를 개발 or 수정하는 도구로 사욯하기 위해 개발되었으며, 시스템 속도를 크게 저하할 수 있으므로 프로덕션 시스템에서는 사용되지 않는다. lockdep 도구는 커널 내에서만 사용하려고 설계되었지만, Pthread mutex 락을 사용하는 사용자 응용 프로그램에서도 교착 상태를 감지하는 데 사용될 수 있다.

lockdep의 대표적인 기능 2가지
- lockdep가 순서대로 획득되지 않은 락을 감지하면 교착 상태가 가능하다고 보고한다.
- Linux에서 스핀락은 인터럽트 핸들러에서 사용될 수 있다. 커널 코드가 인터럽트 처리기에서도 사용되는 락을 획득하는 동안 lockdep이 이너럽트가 활성화되었음을 감지하면 가능한 교착 상태 시나리오를 보고한다.

</aside>

### 8.6.1 안전 상태

- 시스템 상태가 **안전**하다 ****= 시스템이 순서 상관없이 스레드들이 요청하는 **모든 자원을 교착 상태를 야기시키지 않고 차례로 모두 할당해줄 수 있다는 것**.
    - 즉, 시스템이 **안전 순서**를 찾을 수 있다면 시스템은 안전하다고 말할 수 있다.
    
- 안전하다는 것은 교착 상태가 발생하지 않는다는 것을 의미한다.
    - 하지만 불안전하다고 반드시 교착 상태가 발생하는 것은 아니다.
    - 시스템이 **불안전**하다 = 앞으로 교착 상태로 가게 **될 수도** 있다는 것.
    
    ⇒ 그러므로 시스템이 안전 상태에 머무는 한 운영체제는 불안전 상태나 교착 상태 모두를 예방할 수 있다.
    

> 예를 들어, 시스템에 12개의 자원이 있고, 3개의 프로세스(T)가 있다고 하자.
임의의 시점 t0에서 프로세스들은 아래와 같이 자원을 보유하고 있다.
> 

![image](https://user-images.githubusercontent.com/87460638/235684383-6d332938-7851-4e8b-8c23-6e1daf575869.png)

- t0에서 시스템의 상태는 안전하다.
    - <T1, T0, T2> 순서가 있으므로 안전 상태이다.
    - 이유? T1이 시스템 보유분으로 먼저 끝내고 나면, T0이 그 5개를 가져가 끝낼 수 있고, 마지막으로 T2가 끝내면 된다.
- 시스템은 안전 상태에 있다가도 불안전 상태로 전이할 수 있다.
    - t1에서 T2가 자원 한 개를 추가로 요청하여 그것을 주었다고 가정해 보자.
    - 이 상태에서는 T1만이 원하는 자원을 다 할당받을 수 있다.
    - 결과는 교착 상태이다. ⇒ 그러므로 T2가 자원을 한 개 더 달라고 요청을 하더라도 그대로 들어주면 안되고, 다른 스레드가 끝날 때까지 기다리게 했다가 그것을 주어야 교착상태를 피할 수 있다.

- 안전이라는 개념을 통해 회피 알고리즘이 어떻게 교착 상태를 회피할 수 있는지 정의할 수 있다.
    - 기본 원칙은 시스템의 상태가 항상 안전 상태를 떠나지 않도록 고수하는 것이다.
    - 그 후 스레드들이 자원을 요청하면 시스템은 자원을 즉시 할당할 수 있는지 아니면 스레드가 대기해야 하는지 결정해야 한다.

- 하지만 이러한 방식은 스레드가 요청한 자원보다 많은 양을 시스템이 보유하고 있다고 하더라도 그 프로세스를 기다리게 하는 상황이 벌어질 수 있다.
    - 따라서 자원의 이용률은 회피를 안 쓸 때에 비해서 낮아질 수 있다.

### 8.6.2 자원 할당 그래프 알고리즘

- 각 자원 유형마다 단 하나의 인스턴스를 갖는 자원 할당 시스템을 갖고 있다면, 우리는 교착 상태 회피를 위해 정의한 자원 할당 그래프의 변형을 사용할 수 있다.

- 요청 간선과 할당 간서을 추가하여, **예약 간선(claim edge)**이라는 새로운 타입의 간선을 도입한다.
    - 예약간선은 **점선**으로 표시한다.

- 예약 간선의 원리
    - 자원 요청 시: **예약 간선은 요청 간선으로 변환**된다.
    - 방출 요청 시: **요청 간선은 예약 간선으로 변환**된다.

![image](https://user-images.githubusercontent.com/87460638/235684464-7b4f8513-998c-4fc7-b97a-cdd59881f4bd.png)

- 따라서 시스템에서 자원이 반드시 예약되어야 함에 유의하자.
    - 즉, 스레드 Ti가 실행되기 전에, 스레드의 모든 예약 간선이 자원 할당 그래프에 표시되어야 한다.
    - 스레드 Ti와 연관된 모든 간선들이 예약 간선일 때만 예약 간선 Ti → Rj 를 그래프에 추가하도록 허용하면 된다.
    
- 또한 이때 요청 간선 Ti → Rj가 할당 간선으로 변환해도 자원 할당 그래프에 **사이클을 형성하지 않을 때만 요청을 허용**할 수 있다.
    - 이 그래프에서 사이클을 탐지하는 알고리즘은 $n^2$ 차수의 연산이 필요하다. (n = 시스템에 있는 스레드의 수)

- 만약 사이클이 없다면 자원을 할당해도 시스템은 안전 상태가 된다.
    - 사이클이 발견되면, 할당은 시스템을 불안전 상태로 만들 것이다.
    - 그러므로 스레드 Ti는 자신의 요청이 충족될 때까지 **반드시 대기**해야 한다.

### 8.6.3 은행원 알고리즘

- 자원 할당 그래프 알고리즘은 종류마다 자원이 여러 개씩 있게 되면 사용할 수 없다.
- 이와 같은 상황에서 통상 **은행원 알고리즘**을 사용하는데, 이러한 이름이 붙여진 이유는 이 알고리즘을 은행에 적용하면 고객들이 현금을 찾으러 와도 일정한 순서에 의해 모든 고객의 요청을 다 들어줄 수 있게 되기 때문이다.

- 이 시스템에서는 스레드가 시작할 때 스레드가 가지고 있어야 할 자원의 최대 개수를 자원 종류마다 미리 신고하여야 한다.
    - 스레드가 자원들을 요청하면 시스템은 그것을 들어주었을 때 시스템이 계속 안전 상태에 머무르게 되는지 여부를 판단해야 한다.
    - 계속 안전하다면 → 그 요청을 들어준다.
    그렇지 않다면 → 그 요청은 허락이 안된 채 다른 스레드가 끝날 때까지 기다리게 된다.

- 은행원 알고리즘을 구현하려면 몇 가지 자료구조가 필요하다.
    - ***이 자료구조들은 시스템이 자원을 할당하고 있는 상태를 나타내며, 시간이 지남에 따라 값과 크기가 변할 수 있다.***
        
        (n = 스레드의 수 / m = 자원의 종류 수)
        
    - **Available**: 각 종류별로 가용한 자원의 개수를 나타내는 크기 m인 벡터
    - **Max**: 각 스레드가 최대로 필요로 하는 자원의 개수를 나타내는 행렬(n x m).
        - Max[i][j] = k 라면 스레드 Ti가 Rj를 최대 k개까지 요청할 수 있음을 말한다.
    - **Allocation**: 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬 (n x m)
    - **Need**: 각 스레드가 향후 요청할 수 있는 자원의 개수를 나타내는 행렬 (n x m)
        - Need[i][j] = Max[i][j] - Allocation[i][j]의 관계가 있다.

**8.6.3.2 안전성 알고리즘**

- 시스템이 안전한지 아닌지를 알아낼 수 있는 알고리즘은 다음과 같다.
1. Work와 Finish는 크기가 m과 n인 벡터이다. Work = Available로 초기 값을 주고, Finish[i] = false를 초기 값으로 준다.
2. Finish[i] == false 와 $Need_i$ ≤ Work를 만족시키는 i값을 찾는다. 그런 값을 찾지 못하면 단계 4로 간다.
3. Work += $Allocation_i$ , Finish[i] = true. 2단계로 간다.
4. 모든 i값에 대해 Finish[i] == true이면 이 시스템은 안전 상태에 있다.

⇒ 이 알고리즘으로 안전 여부를 알아내는 데에는 $m × n^2$ 개의 연산이 필요하다.

**8.6.3.2 자원 요청 알고리즘**

- 자원 요청이 안전하게 들어줄 수 있는지를 검사하는 알고리즘을 설명한다.
    - $Request_i$ = 스레드 $T_i$의 요청 벡터
1. 만약 $Request_i$ ≤ $Need_i$ 이면 2단계로 간다. 아니면 시스템에 있는 개수보다 더 많이 요청했으므로 오류
2. 만약 $Request_i$ ≤ Available이면 3단계로 간다. 아니면 요청한 자원이 당장은 없으므로 $P_i$는 기다려야 한다.
3. 시스템 상태 정보를 바꾼다.
Available -= $Request_i$  
$Allocation_i$ += $Request_i$ 
$Need_i$  -= $Request_i$ 

- 만일 이렇게 바뀐 상태가 안전하다면 $T_i$에 여기에 반영된 정보대로 자원을 할당해 준다.
    - 그러나 새로운 상태가 불안전하다면, 위의 자원 할당 상태는 원상태로 복원되고 $T_i$는 $Request_i$가 만족하기까지 기다려야 한다.

**8.6.3.3 예시**

> 예를 들어, 시스템에는 다섯 개의 프로세스(T)가 있고, ABC 3가지 종류의 자원이 있다고 가정한다.
시스템에는 A자원이 10개, B자원이 5개, C자원이 7개가 있다.
> 

![image](https://user-images.githubusercontent.com/87460638/235684534-d3e5634f-9d0b-4881-b4bb-7b128cebf697.png)

- Need 행렬값은 (Max - Allocation) 으로부터 얻어진다.

![image](https://user-images.githubusercontent.com/87460638/235684587-5a10c7a4-f101-4c45-973b-992b1ff2930c.png)

- **이 시스템은 안전하다.**
⇒ <T1, T3, T4, T2, T0> 순서는 안정성 기준을 만족시킨다.

> 이제 T1이 A자원 한 개와 C자원 두개를 추가로 요청한다고 가정해 보자.
> 
- 즉 $Request_i$ = (1,0,2) 이다.
- 이 요청을 즉시 들어줄 것인지를 판단하기 위해서는 먼저 $Request_i$ ≤ Available 인지 여부를 검사해야 한다.
    - 즉 (1,0,2) ≤ (3,3,2) 인지 여부를 검사한다.
    
    … ⇒ 이 조건이 만족하므로 다음단계로 마치 이 요청을 들어주는 것처럼 상태 정보를 만들어 보자.
    

![image](https://user-images.githubusercontent.com/87460638/235684645-28874262-4770-47b6-94eb-2f505f3e802b.png)

- 안전선 알고리즘을 돌려보면 <T1, T3, T4, T0, T2>가 안전성 조건을 만족시킨다.
    - 따라서 T1의 요청을 즉시 들어줄 수 있다.
- 이러한 상태에서 T4가 (3,3,0) 을 요청하면 자원이 모자라므로 들어줄 수 없다는 것을 알 수 있다.
    - 또 T0가 (0,2,0)을 요청한다면 자원은 충분히 있지만 상태를 불안전 상태로 만들므로 역시 그 요청을 즉시 들어줄 수 없다는 것을 알 수 있다.

## 8.7 교착 상태 탐지

- 만약 시스템이 교착 상태 예방이나 교착 상태 방지 알고리즘을 사용하지 않는다면, 교착 상태가 발생할 수 있다.
    - 이때 시스템은 다음 알고리즘들을 반드시 지원해야 한다.
        - 교착 상태가 발생했는지 결정하기 위해 시스템의 상태를 겸사하는 알고리즘
        - 교착 상태로부터 회복하는 알고리즘

### 8.7.1 각 자원 유형이 한 개씩 있는 경우

- 모든 자원들이 한 개의 인스턴스만 있다면, **대기 그래프**를 이용하여 교착 상태 탐지 알고리즘을 정의할 수 있다.
- 대기 그래프는 지원 할당 그래프로부터 자원 유형의 노드를 제거하고, 적절한 간선을 결합함으로써 대기 그래프를 얻을 수 있다.

![image](https://user-images.githubusercontent.com/87460638/235684716-5365e835-9eab-4489-838f-b15fdfba7ea3.png)

- 대기 그래프가 사이클을 포함하는 경우에만 시스템에 교착 상태가 존재한다.
    - 교착 상태를 탐지하기 위해 시스템은 대기 그래프를 유지할 필요가 있고, 주기적으로 그래프에서 사이클을 탐지하는 알고리즘을 호출한다.
    - 그래프에서 사이클을 탐지하는 알고리즘은 $O(n^2)$의 연산을 요구한다.
    (n = 그래프에 있는 정점의 수)

### 8.7.2 각 유형의 자원을 여러 개 가진 경우

- 대기 그래프는 종류마다 자원이 여러 개씩 존재하는 상황에서는 사용할 수 없다.
    - 따라서 은행원 알고리즘과 마찬가지로 시시각각 그 내용이 달라지는 자료구조를 사용한다.
    - 8.6.3절과 동일한 방식이며, Allocation과 Request 행령들의 각 행을 벡터로 취급한다.

<aside>
🗣️ **JAVA THREAD DUMPS를 사용한 교착 상태 감지**
 Java는 교착 상태 감지를 명시적으로 지원하지 않지만 스레드 덤프를 사용하여 교착 상태가 있는지 판별하기 위해 실행 중인 프로그램을 분석할 수 있다. 
- **스레드 덤프**는 Java 응용 프로그램의 **스냅숏을 보여주는 유용한 디버깅 도구**이다. 
- Java 스레드 덤프는 또한 봉쇄된 스레드가 획득하려고 기다리고 있는 락을 포함하여 **락 정보를 보여준다.**
- 스레드 덤프가 생성되면 JVM은 대기 그래프를 검색하여 **주기를 감지**하고, **감지된 교착 상태를 보고**한다.
- 실행 중인 응용 프로그램의 스레드 덤프를 생성하려면 명령 라인에서 다음을 입력한다.
`Ctrl-\` : UNIX, Linux, macOS
`Ctrl-Break` : Windows

</aside>

### 8.7.3 탐지 알고리즘 사용

- 탐지 알고리즘을 언제 돌리는 지에 대한 대답은 두 가지 관점에 달려있다.
    1. 교착 상태가 얼마나 자주 일어나는가 ?
    2. 교착 상태가 일어나면 통산 몇 개의 스레드가 거기에 연루되는가 ?

- **교착 상태가 자주 일어난다면 탐지 알고리즘도 자주 돌려야 한다.**
    - 교착 상태가 된 스레드로부터 자원을 회수하기까지는 그 자원들은 아무도 못 쓰는 자원으로 교착 상태 기간내내 묶이게 되기 때문이다.

- 교착 상태가 일어나는 시점은 어떤 스레드가 자원을 요청했는데 그것이 즉시 만족되지 못하는 시점이다.

- 자원을 요청할 때마다 탐지 알고리즘을 호출하면 오버헤드가 너무 크게 되는데, 이에 상응하는 대안은 **한 시간에 한번 또는 CPU 이용률이 40% 이하로 떨어질 때마다 탐지 알고리즘을 호출하는 것**이다.

## 8.8 교착 상태 회복

- 탐지 알고리즘이 교착 상태가 존재한다고 결정하면, 여러 대안의 처리 방법이 있다.
    - 교착 상태가 발생한 것을 운영자에게 통지해 운영자가 **수작업으로 처리**하게 하는 것
    - 시스템이 자동으로 교착 상태로부터 **회복**하게 하는 것

- 교착 상태를 깨뜨리는 데는 두 가지 방법이 있다.
    - 한 개 이상의 스레드를 **중지(abort)**시키는 것
    - 교착 상태에 있는 하나 이상의 스레들로부터 자원을 **선점(preempt)**하는 것

### 8.8.1 프로세스와 스레드의 종료

- 프로세스를 중지시킴으로써 교착 상태를 제거하기 위해 두 가지 방법 중 하나를 사용한다.
    - **교착 상태 프로세스를 모두 중지**
    : 확실하게 교착 상태의 사이클을 깨뜨리지만, 비용이 크다. 이들 계산의 결과물들을 반드시 폐기해야 한다.
    - **교착 상태가 제거될 때까지 한 프로세스씩 중지**
    : 각 프로세스가 중지될 때마다 교착 상태 탐지 알고리즘을 호출해야 하므로 상당한 오버헤드를 유발한다.

- 프로세스들을 중지시켰을 때 유발되는 비용이 최소인 프로세스들을 중지시켜야 한다.
    - 어느 프로세스를 선택할 지 결정하는 데는 다음과 같은 요인들이 있다.
    1. 프로세스의 우선순위가 무엇인지
    2. 지금까지 프로세스가 수행된 시간과 지정된 일을 종료하는 데 더 필요한 시간
    3. 프로세스가 사용한 자원 유형과 수
    4. 프로세스가 종료하기 위해 더 필요한 자원의 수
    5. 얼마나 많은 수의 프로세스가 종료되어야 하는지

### 8.8.2 자원 선점

- 자원 선점을 이용해 교착 상태를 제거하려면, 교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속 선점해 읻르을 다른 프로세스에 주어야 한다.

- 만약 교착 상태를 해결하기 위해 선점이 필요하면, 다음의 3가지 사항들을 고려해야 한다.
    - **희생자 선택**
    : 어느 자원과 어느 프로세스들이 선점될 것인가 ?
    : 비용을 최소화하기 위해 선점의 순서를 결정해야 한다.
    - **후퇴**
    : 프로세스로부터 자원을 선점하려면, 그 프로세스를 어떻게 해야 하는가 ?
    : 안전 상태가 어떤 것인지 결정하기 어렵기 때문에, 프로세스를 중지시키고 재시작하는 것이다.
    - **기아 상태**
    : 기아 상태가 발생하지 않는 것을 어떻게 보장할 것인가 ? 
    (즉, 자원들이 동일한 프로세스로부터 항상 선점되지 않는다는 것을 어떻게 보장할 것인가 ?)
    : 프로세스가 한정된 시간 동안만 희생자로 선정된다는 것을 반드시 보장해야 한다. 대부분의 일반적인 해결법은 비용 요소에 후퇴의 횟수를 포함하는 방법이다.
